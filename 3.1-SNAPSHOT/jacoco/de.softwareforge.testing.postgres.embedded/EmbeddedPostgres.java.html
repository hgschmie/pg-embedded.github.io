<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EmbeddedPostgres.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pg-embedded</a> &gt; <a href="index.source.html" class="el_package">de.softwareforge.testing.postgres.embedded</a> &gt; <span class="el_source">EmbeddedPostgres.java</span></div><h1>EmbeddedPostgres.java</h1><pre class="source lang-java linenums">/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package de.softwareforge.testing.postgres.embedded;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;
import static de.softwareforge.testing.postgres.embedded.DatabaseInfo.PG_DEFAULT_DB;
import static de.softwareforge.testing.postgres.embedded.DatabaseInfo.PG_DEFAULT_USER;
import static de.softwareforge.testing.postgres.embedded.EmbeddedUtil.formatDuration;
import static java.lang.String.format;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.ConnectException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.channels.FileLock;
import java.nio.channels.OverlappingFileLockException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.Duration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.sql.DataSource;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Stopwatch;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.io.CharStreams;
import com.google.common.io.Closeables;
import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import org.postgresql.ds.PGSimpleDataSource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Manages an embedded PostgreSQL server instance.
 */
public final class EmbeddedPostgres implements AutoCloseable {

    /**
     * The version of postgres used if no more specific version has been given.
     */
<span class="fc" id="L72">    public static final String POSTGRES_VERSION = System.getProperty(&quot;pg-embedded.postgres-version&quot;, &quot;13&quot;);</span>

<span class="fc" id="L74">    static final String[] LOCALHOST_SERVER_NAMES = new String[]{&quot;localhost&quot;};</span>

    private static final String PG_TEMPLATE_DB = &quot;template1&quot;;

    @VisibleForTesting
<span class="fc" id="L79">    static final Duration DEFAULT_PG_STARTUP_WAIT = Duration.ofSeconds(10);</span>

    // folders need to be at least 10 minutes old to be considered for deletion.
<span class="fc" id="L82">    private static final long MINIMUM_AGE_IN_MS = Duration.ofMinutes(10).toMillis();</span>

    // prefix for data folders in the parent that might be deleted
    private static final String DATA_DIRECTORY_PREFIX = &quot;epd-&quot;;

    private static final String PG_STOP_MODE = &quot;fast&quot;;
    private static final String PG_STOP_WAIT_SECONDS = &quot;5&quot;;
    static final String LOCK_FILE_NAME = &quot;epg-lock&quot;;

    private final Logger logger;

    private final String instanceId;
    private final File postgresInstallDirectory;
    private final File dataDirectory;

    private final Duration serverStartupWait;
    private final int port;
<span class="fc" id="L99">    private final AtomicBoolean started = new AtomicBoolean();</span>
<span class="fc" id="L100">    private final AtomicBoolean closed = new AtomicBoolean();</span>

    private final ImmutableMap&lt;String, String&gt; serverConfiguration;
    private final ImmutableMap&lt;String, String&gt; localeConfiguration;
    private final ImmutableMap&lt;String, String&gt; connectionProperties;

    private final File lockFile;
    private volatile FileOutputStream lockStream;
    private volatile FileLock lock;

    private final boolean removeDataOnShutdown;

    private final ProcessBuilder.Redirect errorRedirector;
    private final ProcessBuilder.Redirect outputRedirector;


    /**
     * Returns an instance that has been started and configured. The {@link Builder#withDefaults()} configuration has been applied.
     */
    public static EmbeddedPostgres defaultInstance() throws IOException {
<span class="fc" id="L120">        return builderWithDefaults().build();</span>
    }

    /**
     * Returns a builder with default {@link Builder#withDefaults()} configuration already applied.
     */
    public static EmbeddedPostgres.Builder builderWithDefaults() {
<span class="fc" id="L127">        return new Builder().withDefaults();</span>
    }

    /**
     * Returns a new {@link Builder}.
     */
    public static EmbeddedPostgres.Builder builder() {
<span class="fc" id="L134">        return new Builder();</span>
    }

    private EmbeddedPostgres(
            final String instanceId,
            final File postgresInstallDirectory,
            final File dataDirectory,
            final boolean removeDataOnShutdown,
            final Map&lt;String, String&gt; serverConfiguration,
            final Map&lt;String, String&gt; localeConfiguration,
            final Map&lt;String, String&gt; connectionProperties,
            final int port,
            final ProcessBuilder.Redirect errorRedirector,
            final ProcessBuilder.Redirect outputRedirector,
<span class="fc" id="L148">            final Duration serverStartupWait) {</span>

<span class="fc" id="L150">        this.instanceId = checkNotNull(instanceId, &quot;instanceId is null&quot;);</span>

<span class="fc" id="L152">        this.logger = LoggerFactory.getLogger(toString());</span>

<span class="fc" id="L154">        this.postgresInstallDirectory = checkNotNull(postgresInstallDirectory, &quot;postgresInstallDirectory is null&quot;);</span>
<span class="fc" id="L155">        this.dataDirectory = checkNotNull(dataDirectory, &quot;dataDirectory is null&quot;);</span>

<span class="fc" id="L157">        this.removeDataOnShutdown = removeDataOnShutdown;</span>

<span class="fc" id="L159">        this.serverConfiguration = ImmutableMap.copyOf(checkNotNull(serverConfiguration, &quot;serverConfiguration is null&quot;));</span>
<span class="fc" id="L160">        this.localeConfiguration = ImmutableMap.copyOf(checkNotNull(localeConfiguration, &quot;localeConfiguration is null&quot;));</span>
<span class="fc" id="L161">        this.connectionProperties = ImmutableMap.copyOf(checkNotNull(connectionProperties, &quot;connectionProperties is null&quot;));</span>

<span class="fc" id="L163">        this.port = port;</span>

<span class="fc" id="L165">        this.errorRedirector = checkNotNull(errorRedirector, &quot;errorRedirector is null&quot;);</span>
<span class="fc" id="L166">        this.outputRedirector = checkNotNull(outputRedirector, &quot;outputRedirector is null&quot;);</span>

<span class="fc" id="L168">        this.serverStartupWait = checkNotNull(serverStartupWait, &quot;serverStartupWait is null&quot;);</span>
<span class="fc" id="L169">        this.lockFile = new File(this.dataDirectory, LOCK_FILE_NAME);</span>

<span class="fc" id="L171">        logger.debug(format(&quot;data dir is %s, install dir is %s&quot;, this.dataDirectory, this.postgresInstallDirectory));</span>
<span class="fc" id="L172">    }</span>

    /**
     * Creates a {@link DataSource} object that connects to the standard system database.
     * &lt;p&gt;
     * The standard system database is the &lt;pre&gt;template1&lt;/pre&gt; database.
     * &lt;p&gt;
     * Any modification to this database will be propagated to any new database that is created with &lt;pre&gt;CREATE DATABASE...&lt;/pre&gt; unless another database is
     * explicitly named as the template..
     */
    public DataSource createTemplateDataSource() throws SQLException {
<span class="fc" id="L183">        return createDataSource(PG_DEFAULT_USER, PG_TEMPLATE_DB, getPort(), getConnectionProperties());</span>
    }

    /**
     * Creates a {@link DataSource} object that connects to the default database.
     * &lt;p&gt;
     * The default database is the &lt;pre&gt;postgres&lt;/pre&gt; database.
     */
    public DataSource createDefaultDataSource() throws SQLException {
<span class="fc" id="L192">        return createDataSource(PG_DEFAULT_USER, PG_DEFAULT_DB, getPort(), getConnectionProperties());</span>
    }

    /**
     * Creates a {@link DataSource} with a specific user and database name.
     * &lt;p&gt;
     * Creating the DataSource does &lt;b&gt;not&lt;/b&gt; create the database or the user itself. This must be done by the calling code (e.g. with a {@link
     * EmbeddedPostgresPreparer}).
     */
    public DataSource createDataSource(String user, String databaseName) throws SQLException {
<span class="nc" id="L202">        return createDataSource(user, databaseName, getPort(), getConnectionProperties());</span>
    }

    static DataSource createDataSource(String user, String databaseName, int port, Map&lt;String, String&gt; connectionProperties) throws SQLException {
<span class="fc" id="L206">        checkNotNull(user, &quot;user is null&quot;);</span>
<span class="fc" id="L207">        checkNotNull(databaseName, &quot;databaseName is null&quot;);</span>
<span class="fc" id="L208">        checkNotNull(connectionProperties, &quot;connectionProperties is null&quot;);</span>

<span class="fc" id="L210">        final PGSimpleDataSource ds = new PGSimpleDataSource();</span>

<span class="fc" id="L212">        ds.setServerNames(LOCALHOST_SERVER_NAMES);</span>
<span class="fc" id="L213">        ds.setPortNumbers(new int[]{port});</span>
<span class="fc" id="L214">        ds.setDatabaseName(databaseName);</span>
<span class="fc" id="L215">        ds.setUser(user);</span>

<span class="fc bfc" id="L217" title="All 2 branches covered.">        for (final Entry&lt;String, String&gt; entry : connectionProperties.entrySet()) {</span>
<span class="fc" id="L218">            ds.setProperty(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L219">        }</span>

<span class="fc" id="L221">        return ds;</span>
    }

    /**
     * Returns the network (TCP) port for the PostgreSQL server instance.
     */
    public int getPort() {
<span class="fc" id="L228">        return port;</span>
    }

    /**
     * Returns the connection properties for the PostgreSQL server instance.
     */
    ImmutableMap&lt;String, String&gt; getConnectionProperties() {
<span class="fc" id="L235">        return connectionProperties;</span>
    }

    /**
     * Returns the instance id for the PostgreSQL server instance. This id is an alphanumeric string that can be used to differentiate between multiple embedded
     * PostgreSQL server instances.
     */
    public String instanceId() {
<span class="fc" id="L243">        return instanceId;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L248">        return this.getClass().getName() + &quot;$&quot; + this.instanceId;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (this == o) {</span>
<span class="nc" id="L254">            return true;</span>
        }
<span class="nc bnc" id="L256" title="All 4 branches missed.">        if (o == null || getClass() != o.getClass()) {</span>
<span class="nc" id="L257">            return false;</span>
        }
<span class="nc" id="L259">        EmbeddedPostgres that = (EmbeddedPostgres) o;</span>
<span class="nc" id="L260">        return instanceId.equals(that.instanceId);</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L265">        return Objects.hash(instanceId);</span>
    }

    // internal methods
    DatabaseInfo createDefaultDatabaseInfo() {
<span class="fc" id="L270">        return DatabaseInfo.builder().port(getPort()).connectionProperties(getConnectionProperties()).build();</span>
    }


    private void boot() throws IOException {
<span class="fc" id="L275">        EmbeddedUtil.mkdirs(this.dataDirectory);</span>

<span class="pc bpc" id="L277" title="3 of 4 branches missed.">        if (this.removeDataOnShutdown || !new File(this.dataDirectory, &quot;postgresql.conf&quot;).exists()) {</span>
<span class="fc" id="L278">            initDatabase();</span>
        }

<span class="fc" id="L281">        lock();</span>

<span class="fc" id="L283">        startDatabase();</span>
<span class="fc" id="L284">    }</span>


    private synchronized void lock() throws IOException {
<span class="fc" id="L288">        this.lockStream = new FileOutputStream(this.lockFile);</span>
<span class="fc" id="L289">        this.lock = lockStream.getChannel().tryLock();</span>
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">        checkState(lock != null, &quot;could not lock %s&quot;, lockFile);</span>
<span class="fc" id="L291">    }</span>

    private synchronized void unlock() throws IOException {
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">        if (lock != null) {</span>
<span class="fc" id="L295">            lock.release();</span>
        }
<span class="fc" id="L297">        Closeables.close(lockStream, true);</span>
<span class="fc" id="L298">    }</span>

    private void initDatabase() throws IOException {
<span class="fc" id="L301">        ImmutableList.Builder&lt;String&gt; commandBuilder = ImmutableList.builder();</span>
<span class="fc" id="L302">        commandBuilder.add(pgBin(&quot;initdb&quot;))</span>
<span class="fc" id="L303">                .addAll(createLocaleOptions())</span>
<span class="fc" id="L304">                .add(&quot;-A&quot;, &quot;trust&quot;,</span>
                        &quot;-U&quot;, PG_DEFAULT_USER,
<span class="fc" id="L306">                        &quot;-D&quot;, this.dataDirectory.getPath(),</span>
                        &quot;-E&quot;, &quot;UTF-8&quot;);
<span class="fc" id="L308">        final Stopwatch watch = system(commandBuilder.build());</span>
<span class="fc" id="L309">        logger.debug(format(&quot;initdb completed in %s&quot;, formatDuration(watch.elapsed())));</span>
<span class="fc" id="L310">    }</span>

    private void startDatabase() throws IOException {
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        checkState(!started.getAndSet(true), &quot;database already started!&quot;);</span>

<span class="fc" id="L315">        final ImmutableList.Builder&lt;String&gt; commandBuilder = ImmutableList.builder();</span>
<span class="fc" id="L316">        commandBuilder.add(pgBin(&quot;pg_ctl&quot;),</span>
<span class="fc" id="L317">                &quot;-D&quot;, this.dataDirectory.getPath(),</span>
<span class="fc" id="L318">                &quot;-o&quot;, String.join(&quot; &quot;, createInitOptions()),</span>
                &quot;start&quot;
        );

<span class="fc" id="L322">        final Stopwatch watch = Stopwatch.createStarted();</span>
<span class="fc" id="L323">        final Process postmaster = spawn(&quot;pg&quot;, commandBuilder.build());</span>

<span class="fc" id="L325">        logger.info(format(&quot;started as pid %d on port %d&quot;, postmaster.pid(), port));</span>
<span class="fc" id="L326">        logger.debug(format(&quot;Waiting up to %s for server startup to finish&quot;, formatDuration(serverStartupWait)));</span>

<span class="fc" id="L328">        Runtime.getRuntime().addShutdownHook(newCloserThread());</span>

<span class="fc" id="L330">        checkState(waitForServerStartup(), &quot;Could not start pg, interrupted?&quot;);</span>
<span class="fc" id="L331">        logger.debug(format(&quot;startup complete in %s&quot;, formatDuration(watch.elapsed())));</span>
<span class="fc" id="L332">    }</span>

    private void stopDatabase(File dataDirectory) throws IOException {
<span class="fc" id="L335">        final ImmutableList.Builder&lt;String&gt; commandBuilder = ImmutableList.builder();</span>
<span class="fc" id="L336">        commandBuilder.add(pgBin(&quot;pg_ctl&quot;),</span>
<span class="fc" id="L337">                &quot;-D&quot;, dataDirectory.getPath(),</span>
                &quot;stop&quot;,
                &quot;-m&quot;, PG_STOP_MODE,
                &quot;-t&quot;, PG_STOP_WAIT_SECONDS, &quot;-w&quot;);

<span class="fc" id="L342">        final Stopwatch watch = system(commandBuilder.build());</span>
<span class="fc" id="L343">        logger.debug(format(&quot;shutdown complete in %s&quot;, formatDuration(watch.elapsed())));</span>
<span class="fc" id="L344">    }</span>

    private List&lt;String&gt; createInitOptions() {
<span class="fc" id="L347">        final ImmutableList.Builder&lt;String&gt; initOptions = ImmutableList.builder();</span>
<span class="fc" id="L348">        initOptions.add(</span>
<span class="fc" id="L349">                &quot;-p&quot;, Integer.toString(port),</span>
                &quot;-F&quot;);

<span class="fc" id="L352">        serverConfiguration.forEach((k, v) -&gt; {</span>
<span class="fc" id="L353">            initOptions.add(&quot;-c&quot;);</span>
<span class="fc" id="L354">            initOptions.add(k + &quot;=&quot; + v);</span>
<span class="fc" id="L355">        });</span>

<span class="fc" id="L357">        return initOptions.build();</span>
    }

    @VisibleForTesting
    List&lt;String&gt; createLocaleOptions() {
<span class="fc" id="L362">        final ImmutableList.Builder&lt;String&gt; localeOptions = ImmutableList.builder();</span>

<span class="fc" id="L364">        localeConfiguration.forEach((key, value) -&gt; {</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">            if (value.length() &gt; 0) {</span>
<span class="fc" id="L366">                localeOptions.add(&quot;--&quot; + key + &quot;=&quot; + value);</span>
            } else {
<span class="fc" id="L368">                localeOptions.add(&quot;--&quot; + key);</span>
            }
<span class="fc" id="L370">        });</span>
<span class="fc" id="L371">        return localeOptions.build();</span>
    }

    private boolean waitForServerStartup() throws IOException {
<span class="fc" id="L375">        Throwable lastCause = null;</span>
<span class="fc" id="L376">        final long start = System.nanoTime();</span>
<span class="fc" id="L377">        final long maxWaitNs = TimeUnit.NANOSECONDS.convert(serverStartupWait.toMillis(), TimeUnit.MILLISECONDS);</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">        while (System.nanoTime() - start &lt; maxWaitNs) {</span>
            try {
<span class="fc bfc" id="L380" title="All 2 branches covered.">                if (verifyReady()) {</span>
<span class="fc" id="L381">                    return true;</span>
                }
<span class="nc" id="L383">            } catch (final SQLException e) {</span>
<span class="nc" id="L384">                lastCause = e;</span>
<span class="nc" id="L385">                logger.trace(&quot;while waiting for server startup:&quot;, e);</span>
<span class="fc" id="L386">            }</span>

            try {
<span class="fc" id="L389">                Thread.sleep(100);</span>
<span class="nc" id="L390">            } catch (final InterruptedException e) {</span>
<span class="nc" id="L391">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L392">                return false;</span>
<span class="fc" id="L393">            }</span>
        }
<span class="nc" id="L395">        throw new IOException(&quot;Gave up waiting for server to start after &quot; + serverStartupWait.toMillis() + &quot;ms&quot;, lastCause);</span>
    }

    private boolean verifyReady() throws IOException, SQLException {
        // check TCP connection
<span class="fc" id="L400">        final InetAddress localhost = InetAddress.getLoopbackAddress();</span>
<span class="fc" id="L401">        try (Socket sock = new Socket()) {</span>
<span class="fc" id="L402">            sock.setSoTimeout((int) Duration.ofMillis(500).toMillis());</span>
<span class="fc" id="L403">            sock.connect(new InetSocketAddress(localhost, port), (int) Duration.ofMillis(500).toMillis());</span>
<span class="fc" id="L404">        } catch (ConnectException e) {</span>
<span class="fc" id="L405">            return false;</span>
<span class="fc" id="L406">        }</span>

        // check JDBC connection
<span class="fc" id="L409">        try (Connection c = createDefaultDataSource().getConnection();</span>
<span class="fc" id="L410">                Statement s = c.createStatement();</span>
<span class="fc" id="L411">                ResultSet rs = s.executeQuery(&quot;SELECT 1&quot;)) {</span>
<span class="fc" id="L412">            checkState(rs.next(), &quot;expecting single row&quot;);</span>
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">            checkState(rs.getInt(1) == 1, &quot;expecting 1 as result&quot;);</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">            checkState(!rs.next(), &quot;expecting single row&quot;);</span>
<span class="fc" id="L415">            return true;</span>
        }
    }

    private Thread newCloserThread() {
<span class="fc" id="L420">        final Thread closeThread = new Thread(() -&gt; {</span>
            try {
<span class="fc" id="L422">                EmbeddedPostgres.this.close();</span>
<span class="nc" id="L423">            } catch (IOException e) {</span>
<span class="nc" id="L424">                logger.trace(&quot;while closing instance:&quot;, e);</span>
<span class="fc" id="L425">            }</span>
<span class="fc" id="L426">        });</span>

<span class="fc" id="L428">        closeThread.setName(&quot;pg-closer&quot;);</span>
<span class="fc" id="L429">        return closeThread;</span>
    }

    /**
     * Closing an {@link EmbeddedPostgres} instance shuts down the connected database instance.
     */
    @Override
    public void close() throws IOException {
<span class="fc bfc" id="L437" title="All 2 branches covered.">        if (closed.getAndSet(true)) {</span>
<span class="fc" id="L438">            return;</span>
        }

        try {
<span class="fc" id="L442">            stopDatabase(this.dataDirectory);</span>
<span class="nc" id="L443">        } catch (final Exception e) {</span>
<span class="nc" id="L444">            logger.error(&quot;could not stop pg:&quot;, e);</span>
<span class="fc" id="L445">        }</span>

<span class="fc" id="L447">        unlock();</span>

<span class="pc bpc" id="L449" title="1 of 2 branches missed.">        if (removeDataOnShutdown) {</span>
            try {
<span class="fc" id="L451">                EmbeddedUtil.rmdirs(dataDirectory);</span>
<span class="nc" id="L452">            } catch (Exception e) {</span>
<span class="nc" id="L453">                logger.error(format(&quot;Could not clean up directory %s:&quot;, dataDirectory.getAbsolutePath()), e);</span>
<span class="pc" id="L454">            }</span>
        } else {
<span class="nc" id="L456">            logger.debug(format(&quot;preserved data directory %s&quot;, dataDirectory.getAbsolutePath()));</span>
        }
<span class="fc" id="L458">    }</span>

    @VisibleForTesting
    File getDataDirectory() {
<span class="fc" id="L462">        return dataDirectory;</span>
    }

    @VisibleForTesting
    Map&lt;String, String&gt; getLocaleConfiguration() {
<span class="fc" id="L467">        return localeConfiguration;</span>
    }


    @SuppressFBWarnings(&quot;RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE&quot;)
    private void cleanOldDataDirectories(File parentDirectory) {
<span class="fc" id="L473">        final File[] children = parentDirectory.listFiles();</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">        if (children == null) {</span>
<span class="nc" id="L475">            return;</span>
        }
<span class="fc bfc" id="L477" title="All 2 branches covered.">        for (final File dir : children) {</span>
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">            if (!dir.isDirectory()) {</span>
<span class="nc" id="L479">                continue;</span>
            }

            // only ever touch known data directories.
<span class="fc bfc" id="L483" title="All 2 branches covered.">            if (!dir.getName().startsWith(DATA_DIRECTORY_PREFIX)) {</span>
<span class="fc" id="L484">                continue;</span>
            }

            // only touch data directories that hold a lock file.
<span class="fc" id="L488">            final File lockFile = new File(dir, LOCK_FILE_NAME);</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">            if (!lockFile.exists()) {</span>
<span class="fc" id="L490">                continue;</span>
            }

            // file must have a minimum age. This can not be the same check as
            // the exists b/c non-existent files return 0 (epoch) as lastModified so
            // they are considered &quot;ancient&quot;.
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">            if (System.currentTimeMillis() - lockFile.lastModified() &lt; MINIMUM_AGE_IN_MS) {</span>
<span class="fc" id="L497">                continue;</span>
            }

<span class="nc" id="L500">            try (FileOutputStream fos = new FileOutputStream(lockFile);</span>
<span class="nc" id="L501">                    FileLock lock = fos.getChannel().tryLock()) {</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">                if (lock != null) {</span>
<span class="nc" id="L503">                    logger.debug(format(&quot;found stale data directory %s&quot;, dir));</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">                    if (new File(dir, &quot;postmaster.pid&quot;).exists()) {</span>
                        try {
<span class="nc" id="L506">                            stopDatabase(dir);</span>
<span class="nc" id="L507">                            logger.debug(&quot;shutting down orphaned database!&quot;);</span>
<span class="nc" id="L508">                        } catch (Exception e) {</span>
<span class="nc" id="L509">                            logger.warn(format(&quot;failed to orphaned database in %s:&quot;, dir), e);</span>
<span class="nc" id="L510">                        }</span>
                    }
<span class="nc" id="L512">                    EmbeddedUtil.rmdirs(dir);</span>
                }
<span class="nc" id="L514">            } catch (final OverlappingFileLockException e) {</span>
                // The directory belongs to another instance in this VM.
<span class="nc" id="L516">                logger.trace(&quot;while cleaning old data directories:&quot;, e);</span>
<span class="nc" id="L517">            } catch (final Exception e) {</span>
<span class="nc" id="L518">                logger.warn(&quot;while cleaning old data directories:&quot;, e);</span>
<span class="nc" id="L519">            }</span>
        }
<span class="fc" id="L521">    }</span>

    private String pgBin(String binaryName) {
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">        final String extension = EmbeddedUtil.IS_OS_WINDOWS ? &quot;.exe&quot; : &quot;&quot;;</span>
<span class="fc" id="L525">        return new File(this.postgresInstallDirectory, &quot;bin/&quot; + binaryName + extension).getPath();</span>
    }

    private Process spawn(@Nullable String processName, List&lt;String&gt; commandAndArgs) throws IOException {
<span class="fc" id="L529">        final ProcessBuilder builder = new ProcessBuilder(commandAndArgs);</span>
<span class="fc" id="L530">        builder.redirectErrorStream(true);</span>
<span class="fc" id="L531">        builder.redirectError(errorRedirector);</span>
<span class="fc" id="L532">        builder.redirectOutput(outputRedirector);</span>
<span class="fc" id="L533">        final Process process = builder.start();</span>

<span class="pc bpc" id="L535" title="1 of 2 branches missed.">        processName = processName != null ? processName : process.info().command().map(EmbeddedUtil::getFileBaseName).orElse(&quot;&lt;unknown&gt;&quot;);</span>
<span class="fc" id="L536">        String name = format(&quot;%s (%d)&quot;, processName, process.pid());</span>

<span class="fc" id="L538">        ProcessOutputLogger.logOutput(logger, name, process);</span>
<span class="fc" id="L539">        return process;</span>
    }


    private Stopwatch system(List&lt;String&gt; commandAndArgs) throws IOException {
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">        checkArgument(commandAndArgs.size() &gt; 0, &quot;No commandAndArgs given!&quot;);</span>
<span class="fc" id="L545">        String prefix = EmbeddedUtil.getFileBaseName(commandAndArgs.get(0));</span>

<span class="fc" id="L547">        Stopwatch watch = Stopwatch.createStarted();</span>
<span class="fc" id="L548">        Process process = spawn(prefix, commandAndArgs);</span>
        try {
<span class="pc bpc" id="L550" title="1 of 2 branches missed.">            if (process.waitFor() != 0) {</span>
<span class="nc" id="L551">                try (InputStreamReader reader = new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8)) {</span>
<span class="nc" id="L552">                    throw new IllegalStateException(format(&quot;Process %s failed%n%s&quot;,</span>
<span class="nc" id="L553">                            commandAndArgs, CharStreams.toString(reader)));</span>
                }
            }
<span class="nc" id="L556">        } catch (InterruptedException e) {</span>
<span class="nc" id="L557">            Thread.currentThread().interrupt();</span>
<span class="fc" id="L558">        }</span>

<span class="fc" id="L560">        return watch;</span>
    }


    /**
     * Callback interface to customize a builder during creation.
     *
     * @deprecated Use {@link EmbeddedPostgresPreparer} with {@link Builder} as type parameter.
     */
    @Deprecated
    @FunctionalInterface
    public interface BuilderCustomizer {

        /**
         * Callback to customize a given {@link Builder}.
         *
         * @param builder The builder instance. Any method on the builder can be called.
         * @throws SQLException For any SQL related problems.
         * @throws IOException  For any IO related problem.
         */
        void customize(Builder builder) throws IOException, SQLException;
    }

    /**
     * Creates a new {@link EmbeddedPostgres} instance and starts it.
     */
    public static class Builder {

<span class="fc" id="L588">        private File installationBaseDirectory = null;</span>
<span class="fc" id="L589">        private File dataDirectory = null;</span>

<span class="fc" id="L591">        private final Map&lt;String, String&gt; serverConfiguration = new HashMap&lt;&gt;();</span>
<span class="fc" id="L592">        private final Map&lt;String, String&gt; localeConfiguration = new HashMap&lt;&gt;();</span>
<span class="fc" id="L593">        private boolean removeDataOnShutdown = true;</span>
<span class="fc" id="L594">        private int port = 0;</span>
<span class="fc" id="L595">        private final Map&lt;String, String&gt; connectionProperties = new HashMap&lt;&gt;();</span>
<span class="fc" id="L596">        private NativeBinaryManager nativeBinaryManager = null;</span>
<span class="fc" id="L597">        private Duration serverStartupWait = DEFAULT_PG_STARTUP_WAIT;</span>

<span class="fc" id="L599">        private ProcessBuilder.Redirect errRedirector = ProcessBuilder.Redirect.PIPE;</span>
<span class="fc" id="L600">        private ProcessBuilder.Redirect outRedirector = ProcessBuilder.Redirect.PIPE;</span>

<span class="fc" id="L602">        Builder() {</span>
<span class="fc" id="L603">        }</span>

        /**
         * Apply a set of defaults to the database server:
         * &lt;ul&gt;
         *     &lt;li&gt;timezone: UTC&lt;/li&gt;
         *     &lt;li&gt;synchronous_commit: off&lt;/li&gt;
         *     &lt;li&gt;max_connections: 300&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * @return The builder itself.
         */
        public Builder withDefaults() {
<span class="fc" id="L616">            serverConfiguration.put(&quot;timezone&quot;, &quot;UTC&quot;);</span>
<span class="fc" id="L617">            serverConfiguration.put(&quot;synchronous_commit&quot;, &quot;off&quot;);</span>
<span class="fc" id="L618">            serverConfiguration.put(&quot;max_connections&quot;, &quot;300&quot;);</span>
<span class="fc" id="L619">            return this;</span>
        }

        /**
         * Sets the time that the builder will wait for the PostgreSQL server instance to start. Default is 10 seconds.
         *
         * @param serverStartupWait Startup wait time. Must not be null or negative.
         * @return The builder itself.
         */
        public Builder setServerStartupWait(@NonNull Duration serverStartupWait) {
<span class="nc" id="L629">            checkNotNull(serverStartupWait, &quot;serverStartupWait is null&quot;);</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">            checkArgument(!serverStartupWait.isNegative(), &quot;Negative durations are not permitted.&quot;);</span>

<span class="nc" id="L632">            this.serverStartupWait = serverStartupWait;</span>
<span class="nc" id="L633">            return this;</span>
        }

        /**
         * Whether to remove the data directory on server shutdown. If true, the contents of the data directory are deleted when the {@link EmbeddedPostgres}
         * instance is closed. Default is true.
         *
         * @param removeDataOnShutdown True removes the contents of the data directory on shutdown.
         * @return The builder itself.
         */
        public Builder setRemoveDataOnShutdown(boolean removeDataOnShutdown) {
<span class="nc" id="L644">            this.removeDataOnShutdown = removeDataOnShutdown;</span>
<span class="nc" id="L645">            return this;</span>
        }

        /**
         * Explicitly set the location of the data directory. Default is using a managed directory.
         *
         * @param dataDirectory The directory to use. Must not be null. If it exists, the current user must be able to access the directory for reading and
         *                      writing. If the directory does not exist then the current user must be able to create it for reading and writing.
         * @return The builder itself.
         */
        public Builder setDataDirectory(@NonNull Path dataDirectory) {
<span class="fc" id="L656">            checkNotNull(dataDirectory, &quot;dataDirectory is null&quot;);</span>
<span class="fc" id="L657">            return setDataDirectory(dataDirectory.toFile());</span>
        }

        /**
         * Explicitly set the location of the data directory. Default is using a managed directory.
         *
         * @param dataDirectory The directory to use. Must not be null. If it exists, the current user must be able to access the directory for reading and
         *                      writing. If the directory does not exist then the current user must be able to create it for reading and writing.
         * @return The builder itself.
         */
        public Builder setDataDirectory(@NonNull String dataDirectory) {
<span class="nc" id="L668">            checkNotNull(dataDirectory, &quot;dataDirectory is null&quot;);</span>
<span class="nc" id="L669">            return setDataDirectory(new File(dataDirectory));</span>
        }

        /**
         * Explicitly set the location of the data directory. Default is using a managed directory.
         *
         * @param dataDirectory The directory to use. Must not be null. If it exists, the current user must be able to access the directory for reading and
         *                      writing. If the directory does not exist then the current user must be able to create it for reading and writing.
         * @return The builder itself.
         */
        public Builder setDataDirectory(@NonNull File dataDirectory) {
<span class="fc" id="L680">            this.dataDirectory = checkNotNull(dataDirectory, &quot;dataDirectory is null&quot;);</span>
<span class="fc" id="L681">            return this;</span>
        }

        /**
         * Adds a server configuration parameter. All parameters are passed to the PostgreSQL server a startup using the &lt;code&gt;postgres&lt;/code&gt; command.
         * &lt;p&gt;
         * Values and their function are specific to the PostgreSQL version selected.
         * &lt;p&gt;
         * See &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;the PostgreSQL runtime configuration&lt;/a&gt; for more information.
         *
         * @param key   Configuration parameter name. Must not be null.
         * @param value Configuration parameter value. Must not be null.
         * @return The builder itself.
         */
        public Builder addServerConfiguration(@NonNull String key, @NonNull String value) {
<span class="fc" id="L696">            checkNotNull(key, &quot;key is null&quot;);</span>
<span class="fc" id="L697">            checkNotNull(value, &quot;value is null&quot;);</span>
<span class="fc" id="L698">            this.serverConfiguration.put(key, value);</span>
<span class="fc" id="L699">            return this;</span>
        }

        /**
         * @deprecated Use {@link #addInitDbConfiguration(String, String)}.
         */
        @Deprecated
        public Builder addLocaleConfiguration(@NonNull String key, @NonNull String value) {
<span class="nc" id="L707">            checkNotNull(key, &quot;key is null&quot;);</span>
<span class="nc" id="L708">            checkNotNull(value, &quot;value is null&quot;);</span>
<span class="nc" id="L709">            this.localeConfiguration.put(key, value);</span>
<span class="nc" id="L710">            return this;</span>
        }

        /**
         * Adds a configuration parameters for the &lt;code&gt;initdb&lt;/code&gt; command. The &lt;code&gt;initdb&lt;/code&gt; command is used to create the PostgreSQL server.
         * &lt;p&gt;
         * Each value is added as a command line parameter to the command.
         * &lt;p&gt;
         * See https://www.postgresql.org/docs/13/app-initdb.html for an overview of possible values.
         *
         * @param key   initdb parameter name. Must not be null.
         * @param value initdb parameter value. Must not be null. When the empty string is used as the value, the resulting command line parameter will not have
         *              a equal sign and a value assigned.
         * @return The builder itself.
         */
        public Builder addInitDbConfiguration(@NonNull String key, @NonNull String value) {
<span class="fc" id="L726">            checkNotNull(key, &quot;key is null&quot;);</span>
<span class="fc" id="L727">            checkNotNull(value, &quot;value is null&quot;);</span>
<span class="fc" id="L728">            this.localeConfiguration.put(key, value);</span>
<span class="fc" id="L729">            return this;</span>
        }

        /**
         * Adds a connection property. These properties are set on every connection handed out by the data source. See
         * &lt;a href=&quot;https://jdbc.postgresql.org/documentation/head/connect.html#connection-parameters&quot;&gt;the
         * PostgreSQL JDBC driver documentation&lt;/a&gt; for possible values.
         *
         * @param key   connection property name. Must not be null.
         * @param value connection property value. Must not be null.
         * @return The builder itself.
         */
        public Builder addConnectionProperty(@NonNull String key, @NonNull String value) {
<span class="fc" id="L742">            checkNotNull(key, &quot;key is null&quot;);</span>
<span class="fc" id="L743">            checkNotNull(value, &quot;value is null&quot;);</span>
<span class="fc" id="L744">            this.connectionProperties.put(key, value);</span>
<span class="fc" id="L745">            return this;</span>
        }

        /**
         * Sets the directory where the PostgreSQL distribution is unpacked. Setting the installation base directory resets the {@link NativeBinaryManager} used
         * to locate the postgres installation back to the default (which is to download the zonky.io Postgres archive and unpack it in the installation
         * directory. The default is using a managed directory.
         *
         * @param installationBaseDirectory The directory to unpack the postgres distribution. The current user must be able to create and write this directory.
         *                                  Must not be null.
         * @return The builder itself.
         */
        public Builder setInstallationBaseDirectory(@NonNull File installationBaseDirectory) {
<span class="nc" id="L758">            checkNotNull(installationBaseDirectory, &quot;installationBaseDirectory is null&quot;);</span>
<span class="nc" id="L759">            this.installationBaseDirectory = installationBaseDirectory;</span>
<span class="nc" id="L760">            this.nativeBinaryManager = null;</span>
<span class="nc" id="L761">            return this;</span>
        }

        /**
         * Explicitly set the TCP port for the PostgresQL server. If the port is not available, starting the server will fail. Default is to find and use an
         * available TCP port.
         *
         * @param port The port to use. Must be &amp;gt; 1023 and &amp;lt; 65536.
         * @return The builder itself.
         */
        public Builder setPort(int port) {
<span class="nc bnc" id="L772" title="All 4 branches missed.">            checkState(port &gt; 1023 &amp;&amp; port &lt; 65535, &quot;Port %s is not within 1024..65535&quot;, port);</span>
<span class="nc" id="L773">            this.port = port;</span>
<span class="nc" id="L774">            return this;</span>
        }

        /**
         * Set a {@link ProcessBuilder.Redirect} instance to receive stderr output from the spawned processes.
         *
         * @param errRedirector a {@link ProcessBuilder.Redirect} instance. Must not be null.
         * @return The builder itself.
         */
        public Builder setErrorRedirector(@NonNull ProcessBuilder.Redirect errRedirector) {
<span class="nc" id="L784">            this.errRedirector = checkNotNull(errRedirector, &quot;errRedirector is null&quot;);</span>
<span class="nc" id="L785">            return this;</span>
        }

        /**
         * Set a {@link ProcessBuilder.Redirect} instance to receive stdout output from the spawned processes.
         *
         * @param outRedirector a {@link ProcessBuilder.Redirect} instance. Must not be null.
         * @return The builder itself.
         */
        public Builder setOutputRedirector(@NonNull ProcessBuilder.Redirect outRedirector) {
<span class="nc" id="L795">            this.outRedirector = checkNotNull(outRedirector, &quot;outRedirector is null&quot;);</span>
<span class="nc" id="L796">            return this;</span>
        }

        /**
         * Sets the {@link NativeBinaryManager} that provides the location of the postgres installation. Explicitly setting a binary manager overrides the
         * installation base directory location set with {@link #setInstallationBaseDirectory(File)} as this is only used by the default binary manager. Calling
         * {@link #setInstallationBaseDirectory(File)} after this method undoes setting the binary manager.
         *
         * @param nativeBinaryManager A {@link NativeBinaryManager} implementation. Must not be null.
         * @return The builder itself.
         */
        public Builder setNativeBinaryManager(@NonNull NativeBinaryManager nativeBinaryManager) {
<span class="fc" id="L808">            this.nativeBinaryManager = checkNotNull(nativeBinaryManager, &quot;nativeBinaryManager is null&quot;);</span>
<span class="fc" id="L809">            return this;</span>
        }

        /**
         * Use a locally installed PostgreSQL server for tests. The tests will still spin up a new instance and locate the data in the data directory but it
         * will use the locally installed binaries for starting and stopping. Calling this method sets a binary manager, so it overrides {@link
         * #setNativeBinaryManager(NativeBinaryManager)}. Calling this method makes the builder ignore the {@link #setInstallationBaseDirectory(File)} setting.
         *
         * @param directory A local directory that contains a standard PostgreSQL installation. The directory must exist and read and executable.
         * @return The builder itself.
         */
        public Builder useLocalPostgresInstallation(@NonNull File directory) {
<span class="fc" id="L821">            checkNotNull(directory, &quot;directory is null&quot;);</span>
<span class="pc bpc" id="L822" title="2 of 4 branches missed.">            checkState(directory.exists() &amp;&amp; directory.isDirectory(), &quot;'%s' either does not exist or is not a directory!&quot;, directory);</span>
<span class="fc" id="L823">            return setNativeBinaryManager(() -&gt; directory);</span>
        }

        /**
         * Creates and boots a new {@link EmbeddedPostgres} instance.
         *
         * @return A {@link EmbeddedPostgres} instance representing a started PostgreSQL server.
         * @throws IOException If the server could not be installed or started.
         */
        public EmbeddedPostgres build() throws IOException {
            // Builder Id
<span class="fc" id="L834">            final String instanceId = EmbeddedUtil.randomAlphaNumeric(16);</span>

<span class="pc bpc" id="L836" title="1 of 2 branches missed.">            int port = this.port != 0 ? this.port : EmbeddedUtil.allocatePort();</span>

            // installation root if nothing has been set by the user.
<span class="fc" id="L839">            final File parentDirectory = EmbeddedUtil.getWorkingDirectory();</span>
<span class="fc" id="L840">            EmbeddedUtil.mkdirs(parentDirectory);</span>

<span class="fc" id="L842">            NativeBinaryManager nativeBinaryManager = this.nativeBinaryManager;</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">            if (nativeBinaryManager == null) {</span>
                // Use the parent directory if no installation directory set.
<span class="fc" id="L845">                File installationBaseDirectory = Objects.requireNonNullElse(this.installationBaseDirectory, parentDirectory);</span>
<span class="fc" id="L846">                nativeBinaryManager = new TarXzCompressedBinaryManager(installationBaseDirectory,</span>
                        EmbeddedPostgres.LOCK_FILE_NAME, new ZonkyIOPostgresLocator());
            }

            // this is where the binary manager actually places the unpackaged postgres installation.
<span class="fc" id="L851">            final File postgresInstallDirectory = nativeBinaryManager.getLocation();</span>

<span class="fc" id="L853">            File dataDirectory = this.dataDirectory;</span>
<span class="fc bfc" id="L854" title="All 2 branches covered.">            if (dataDirectory == null) {</span>
<span class="fc" id="L855">                dataDirectory = new File(parentDirectory, DATA_DIRECTORY_PREFIX + instanceId);</span>
            }

<span class="fc" id="L858">            EmbeddedPostgres embeddedPostgres = new EmbeddedPostgres(instanceId, postgresInstallDirectory, dataDirectory,</span>
                    removeDataOnShutdown, serverConfiguration, localeConfiguration, connectionProperties,
                    port, errRedirector, outRedirector,
                    serverStartupWait);

<span class="fc" id="L863">            embeddedPostgres.cleanOldDataDirectories(parentDirectory);</span>

<span class="fc" id="L865">            embeddedPostgres.boot();</span>

<span class="fc" id="L867">            return embeddedPostgres;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>