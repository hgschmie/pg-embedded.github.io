<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EmbeddedPostgres.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pg-embedded</a> &gt; <a href="index.source.html" class="el_package">de.softwareforge.testing.postgres.embedded</a> &gt; <span class="el_source">EmbeddedPostgres.java</span></div><h1>EmbeddedPostgres.java</h1><pre class="source lang-java linenums">/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package de.softwareforge.testing.postgres.embedded;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;
import static de.softwareforge.testing.postgres.embedded.DatabaseInfo.PG_DEFAULT_DB;
import static de.softwareforge.testing.postgres.embedded.DatabaseInfo.PG_DEFAULT_USER;
import static de.softwareforge.testing.postgres.embedded.EmbeddedUtil.formatDuration;
import static java.lang.String.format;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.ConnectException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.channels.FileLock;
import java.nio.channels.OverlappingFileLockException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.Duration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.sql.DataSource;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Stopwatch;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.io.CharStreams;
import com.google.common.io.Closeables;
import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;
import org.postgresql.ds.PGSimpleDataSource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Manages an embedded PostgreSQL server instance.
 */
public final class EmbeddedPostgres implements AutoCloseable {

    /**
     * The version of postgres used if no more specific version has been given.
     */
<span class="fc" id="L71">    public static final String POSTGRES_VERSION = System.getProperty(&quot;pg-embedded.postgres-version&quot;, &quot;13&quot;);</span>

<span class="fc" id="L73">    static final String[] LOCALHOST_SERVER_NAMES = new String[]{&quot;localhost&quot;};</span>

    private static final String PG_TEMPLATE_DB = &quot;template1&quot;;

    @VisibleForTesting
<span class="fc" id="L78">    static final Duration DEFAULT_PG_STARTUP_WAIT = Duration.ofSeconds(10);</span>

    // folders need to be at least 10 minutes old to be considered for deletion.
<span class="fc" id="L81">    private static final long MINIMUM_AGE_IN_MS = Duration.ofMinutes(10).toMillis();</span>

    // prefix for data folders in the parent that might be deleted
    private static final String DATA_DIRECTORY_PREFIX = &quot;data-&quot;;

    private static final String PG_STOP_MODE = &quot;fast&quot;;
    private static final String PG_STOP_WAIT_SECONDS = &quot;5&quot;;
    static final String LOCK_FILE_NAME = &quot;epg-lock&quot;;

    private final Logger logger;

    private final String instanceId;
    private final File postgresInstallDirectory;
    private final File dataDirectory;

    private final Duration serverStartupWait;
    private final int port;
<span class="fc" id="L98">    private final AtomicBoolean started = new AtomicBoolean();</span>
<span class="fc" id="L99">    private final AtomicBoolean closed = new AtomicBoolean();</span>

    private final ImmutableMap&lt;String, String&gt; serverConfiguration;
    private final ImmutableMap&lt;String, String&gt; localeConfiguration;
    private final ImmutableMap&lt;String, String&gt; connectionProperties;

    private final File lockFile;
    private volatile FileOutputStream lockStream;
    private volatile FileLock lock;

    private final boolean removeDataOnShutdown;

    private final ProcessBuilder.Redirect errorRedirector;
    private final ProcessBuilder.Redirect outputRedirector;


    /**
     * Returns an instance that has been started and configured. The {@link Builder#withDefaults()} configuration has been applied.
     */
    @NonNull
    public static EmbeddedPostgres defaultInstance() throws IOException {
<span class="fc" id="L120">        return builderWithDefaults().build();</span>
    }

    /**
     * Returns a builder with default {@link Builder#withDefaults()} configuration already applied.
     */
    @NonNull
    public static EmbeddedPostgres.Builder builderWithDefaults() {
<span class="fc" id="L128">        return new Builder().withDefaults();</span>
    }

    /**
     * Returns a new {@link Builder}.
     */
    @NonNull
    public static EmbeddedPostgres.Builder builder() {
<span class="fc" id="L136">        return new Builder();</span>
    }

    private EmbeddedPostgres(
            final String instanceId,
            final File postgresInstallDirectory,
            final File dataDirectory,
            final boolean removeDataOnShutdown,
            final Map&lt;String, String&gt; serverConfiguration,
            final Map&lt;String, String&gt; localeConfiguration,
            final Map&lt;String, String&gt; connectionProperties,
            final int port,
            final ProcessBuilder.Redirect errorRedirector,
            final ProcessBuilder.Redirect outputRedirector,
<span class="fc" id="L150">            final Duration serverStartupWait) {</span>

<span class="fc" id="L152">        this.instanceId = checkNotNull(instanceId, &quot;instanceId is null&quot;);</span>

<span class="fc" id="L154">        this.logger = LoggerFactory.getLogger(toString());</span>

<span class="fc" id="L156">        this.postgresInstallDirectory = checkNotNull(postgresInstallDirectory, &quot;postgresInstallDirectory is null&quot;);</span>
<span class="fc" id="L157">        this.dataDirectory = checkNotNull(dataDirectory, &quot;dataDirectory is null&quot;);</span>

<span class="fc" id="L159">        this.removeDataOnShutdown = removeDataOnShutdown;</span>

<span class="fc" id="L161">        this.serverConfiguration = ImmutableMap.copyOf(checkNotNull(serverConfiguration, &quot;serverConfiguration is null&quot;));</span>
<span class="fc" id="L162">        this.localeConfiguration = ImmutableMap.copyOf(checkNotNull(localeConfiguration, &quot;localeConfiguration is null&quot;));</span>
<span class="fc" id="L163">        this.connectionProperties = ImmutableMap.copyOf(checkNotNull(connectionProperties, &quot;connectionProperties is null&quot;));</span>

<span class="fc" id="L165">        this.port = port;</span>

<span class="fc" id="L167">        this.errorRedirector = checkNotNull(errorRedirector, &quot;errorRedirector is null&quot;);</span>
<span class="fc" id="L168">        this.outputRedirector = checkNotNull(outputRedirector, &quot;outputRedirector is null&quot;);</span>

<span class="fc" id="L170">        this.serverStartupWait = checkNotNull(serverStartupWait, &quot;serverStartupWait is null&quot;);</span>
<span class="fc" id="L171">        this.lockFile = new File(this.dataDirectory, LOCK_FILE_NAME);</span>

<span class="fc" id="L173">        logger.debug(format(&quot;data dir is %s, install dir is %s&quot;, this.dataDirectory, this.postgresInstallDirectory));</span>
<span class="fc" id="L174">    }</span>

    /**
     * Creates a {@link DataSource} object that connects to the standard system database.
     * &lt;p&gt;
     * The standard system database is the &lt;code&gt;template1&lt;/code&gt; database.
     * &lt;p&gt;
     * Any modification to this database will be propagated to any new database that is created with &lt;code&gt;CREATE DATABASE...&lt;/code&gt; unless another database is
     * explicitly named as the template..
     */
    @NonNull
    public DataSource createTemplateDataSource() throws SQLException {
<span class="fc" id="L186">        return createDataSource(PG_DEFAULT_USER, PG_TEMPLATE_DB, getPort(), getConnectionProperties());</span>
    }

    /**
     * Creates a {@link DataSource} object that connects to the default database.
     * &lt;p&gt;
     * The default database is the &lt;code&gt;postgres&lt;/code&gt; database.
     */
    @NonNull
    public DataSource createDefaultDataSource() throws SQLException {
<span class="fc" id="L196">        return createDataSource(PG_DEFAULT_USER, PG_DEFAULT_DB, getPort(), getConnectionProperties());</span>
    }

    /**
     * Creates a {@link DataSource} with a specific user and database name.
     * &lt;p&gt;
     * Creating the DataSource does &lt;b&gt;not&lt;/b&gt; create the database or the user itself. This must be done by the calling code (e.g. with a {@link
     * EmbeddedPostgresPreparer}).
     */
    @NonNull
    public DataSource createDataSource(@NonNull String user, @NonNull String databaseName) throws SQLException {
<span class="nc" id="L207">        return createDataSource(user, databaseName, getPort(), getConnectionProperties());</span>
    }

    static DataSource createDataSource(String user, String databaseName, int port, Map&lt;String, String&gt; connectionProperties) throws SQLException {
<span class="fc" id="L211">        checkNotNull(user, &quot;user is null&quot;);</span>
<span class="fc" id="L212">        checkNotNull(databaseName, &quot;databaseName is null&quot;);</span>
<span class="fc" id="L213">        checkNotNull(connectionProperties, &quot;connectionProperties is null&quot;);</span>

<span class="fc" id="L215">        final PGSimpleDataSource ds = new PGSimpleDataSource();</span>

<span class="fc" id="L217">        ds.setServerNames(LOCALHOST_SERVER_NAMES);</span>
<span class="fc" id="L218">        ds.setPortNumbers(new int[]{port});</span>
<span class="fc" id="L219">        ds.setDatabaseName(databaseName);</span>
<span class="fc" id="L220">        ds.setUser(user);</span>

<span class="fc bfc" id="L222" title="All 2 branches covered.">        for (final Entry&lt;String, String&gt; entry : connectionProperties.entrySet()) {</span>
<span class="fc" id="L223">            ds.setProperty(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L224">        }</span>

<span class="fc" id="L226">        return ds;</span>
    }

    /**
     * Returns the network (TCP) port for the PostgreSQL server instance.
     */
    public int getPort() {
<span class="fc" id="L233">        return port;</span>
    }

    /**
     * Returns the connection properties for the PostgreSQL server instance.
     */
    @NonNull
    ImmutableMap&lt;String, String&gt; getConnectionProperties() {
<span class="fc" id="L241">        return connectionProperties;</span>
    }

    /**
     * Returns the instance id for the PostgreSQL server instance. This id is an alphanumeric string that can be used to differentiate between multiple embedded
     * PostgreSQL server instances.
     */
    @NonNull
    public String instanceId() {
<span class="fc" id="L250">        return instanceId;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L255">        return this.getClass().getName() + &quot;$&quot; + this.instanceId;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (this == o) {</span>
<span class="nc" id="L261">            return true;</span>
        }
<span class="nc bnc" id="L263" title="All 4 branches missed.">        if (o == null || getClass() != o.getClass()) {</span>
<span class="nc" id="L264">            return false;</span>
        }
<span class="nc" id="L266">        EmbeddedPostgres that = (EmbeddedPostgres) o;</span>
<span class="nc" id="L267">        return instanceId.equals(that.instanceId);</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L272">        return Objects.hash(instanceId);</span>
    }

    // internal methods
    DatabaseInfo createDefaultDatabaseInfo() {
<span class="fc" id="L277">        return DatabaseInfo.builder().port(getPort()).connectionProperties(getConnectionProperties()).build();</span>
    }


    private void boot() throws IOException {
<span class="fc" id="L282">        EmbeddedUtil.mkdirs(this.dataDirectory);</span>

<span class="pc bpc" id="L284" title="3 of 4 branches missed.">        if (this.removeDataOnShutdown || !new File(this.dataDirectory, &quot;postgresql.conf&quot;).exists()) {</span>
<span class="fc" id="L285">            initDatabase();</span>
        }

<span class="fc" id="L288">        lock();</span>

<span class="fc" id="L290">        startDatabase();</span>
<span class="fc" id="L291">    }</span>


    private synchronized void lock() throws IOException {
<span class="fc" id="L295">        this.lockStream = new FileOutputStream(this.lockFile);</span>
<span class="fc" id="L296">        this.lock = lockStream.getChannel().tryLock();</span>
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        checkState(lock != null, &quot;could not lock %s&quot;, lockFile);</span>
<span class="fc" id="L298">    }</span>

    private synchronized void unlock() throws IOException {
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        if (lock != null) {</span>
<span class="fc" id="L302">            lock.release();</span>
        }
<span class="fc" id="L304">        Closeables.close(lockStream, true);</span>
<span class="fc" id="L305">    }</span>

    private void initDatabase() throws IOException {
<span class="fc" id="L308">        ImmutableList.Builder&lt;String&gt; commandBuilder = ImmutableList.builder();</span>
<span class="fc" id="L309">        commandBuilder.add(pgBin(&quot;initdb&quot;))</span>
<span class="fc" id="L310">                .addAll(createInitDbOptions())</span>
<span class="fc" id="L311">                .add(&quot;-A&quot;, &quot;trust&quot;,</span>
                        &quot;-U&quot;, PG_DEFAULT_USER,
<span class="fc" id="L313">                        &quot;-D&quot;, this.dataDirectory.getPath(),</span>
                        &quot;-E&quot;, &quot;UTF-8&quot;);
<span class="fc" id="L315">        final Stopwatch watch = system(commandBuilder.build());</span>
<span class="fc" id="L316">        logger.debug(format(&quot;initdb completed in %s&quot;, formatDuration(watch.elapsed())));</span>
<span class="fc" id="L317">    }</span>

    private void startDatabase() throws IOException {
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">        checkState(!started.getAndSet(true), &quot;database already started!&quot;);</span>

<span class="fc" id="L322">        final ImmutableList.Builder&lt;String&gt; commandBuilder = ImmutableList.builder();</span>
<span class="fc" id="L323">        commandBuilder.add(pgBin(&quot;pg_ctl&quot;),</span>
<span class="fc" id="L324">                &quot;-D&quot;, this.dataDirectory.getPath(),</span>
<span class="fc" id="L325">                &quot;-o&quot;, String.join(&quot; &quot;, createInitOptions()),</span>
                &quot;start&quot;
        );

<span class="fc" id="L329">        final Stopwatch watch = Stopwatch.createStarted();</span>
<span class="fc" id="L330">        final Process postmaster = spawn(&quot;pg&quot;, commandBuilder.build());</span>

<span class="fc" id="L332">        logger.info(format(&quot;started as pid %d on port %d&quot;, postmaster.pid(), port));</span>
<span class="fc" id="L333">        logger.debug(format(&quot;Waiting up to %s for server startup to finish&quot;, formatDuration(serverStartupWait)));</span>

<span class="fc" id="L335">        Runtime.getRuntime().addShutdownHook(newCloserThread());</span>

<span class="fc" id="L337">        checkState(waitForServerStartup(), &quot;Could not start pg, interrupted?&quot;);</span>
<span class="fc" id="L338">        logger.debug(format(&quot;startup complete in %s&quot;, formatDuration(watch.elapsed())));</span>
<span class="fc" id="L339">    }</span>

    private void stopDatabase(File dataDirectory) throws IOException {
<span class="fc" id="L342">        final ImmutableList.Builder&lt;String&gt; commandBuilder = ImmutableList.builder();</span>
<span class="fc" id="L343">        commandBuilder.add(pgBin(&quot;pg_ctl&quot;),</span>
<span class="fc" id="L344">                &quot;-D&quot;, dataDirectory.getPath(),</span>
                &quot;stop&quot;,
                &quot;-m&quot;, PG_STOP_MODE,
                &quot;-t&quot;, PG_STOP_WAIT_SECONDS, &quot;-w&quot;);

<span class="fc" id="L349">        final Stopwatch watch = system(commandBuilder.build());</span>
<span class="fc" id="L350">        logger.debug(format(&quot;shutdown complete in %s&quot;, formatDuration(watch.elapsed())));</span>
<span class="fc" id="L351">    }</span>

    private List&lt;String&gt; createInitOptions() {
<span class="fc" id="L354">        final ImmutableList.Builder&lt;String&gt; initOptions = ImmutableList.builder();</span>
<span class="fc" id="L355">        initOptions.add(</span>
<span class="fc" id="L356">                &quot;-p&quot;, Integer.toString(port),</span>
                &quot;-F&quot;);

<span class="fc" id="L359">        serverConfiguration.forEach((key, value) -&gt; {</span>
<span class="fc" id="L360">            initOptions.add(&quot;-c&quot;);</span>
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">            if (value.length() &gt; 0) {</span>
<span class="fc" id="L362">                initOptions.add(key + &quot;=&quot; + value);</span>
            } else {
<span class="nc" id="L364">                initOptions.add(key + &quot;=true&quot;);</span>
            }
<span class="fc" id="L366">        });</span>

<span class="fc" id="L368">        return initOptions.build();</span>
    }

    @VisibleForTesting
    List&lt;String&gt; createInitDbOptions() {
<span class="fc" id="L373">        final ImmutableList.Builder&lt;String&gt; localeOptions = ImmutableList.builder();</span>

<span class="fc" id="L375">        localeConfiguration.forEach((key, value) -&gt; {</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">            if (value.length() &gt; 0) {</span>
<span class="fc" id="L377">                localeOptions.add(&quot;--&quot; + key + &quot;=&quot; + value);</span>
            } else {
<span class="fc" id="L379">                localeOptions.add(&quot;--&quot; + key);</span>
            }
<span class="fc" id="L381">        });</span>
<span class="fc" id="L382">        return localeOptions.build();</span>
    }

    private boolean waitForServerStartup() throws IOException {
<span class="fc" id="L386">        Throwable lastCause = null;</span>
<span class="fc" id="L387">        final long start = System.nanoTime();</span>
<span class="fc" id="L388">        final long maxWaitNs = TimeUnit.NANOSECONDS.convert(serverStartupWait.toMillis(), TimeUnit.MILLISECONDS);</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        while (System.nanoTime() - start &lt; maxWaitNs) {</span>
            try {
<span class="fc bfc" id="L391" title="All 2 branches covered.">                if (verifyReady()) {</span>
<span class="fc" id="L392">                    return true;</span>
                }
<span class="nc" id="L394">            } catch (final SQLException e) {</span>
<span class="nc" id="L395">                lastCause = e;</span>
<span class="nc" id="L396">                logger.trace(&quot;while waiting for server startup:&quot;, e);</span>
<span class="fc" id="L397">            }</span>

            try {
<span class="fc" id="L400">                Thread.sleep(100);</span>
<span class="nc" id="L401">            } catch (final InterruptedException e) {</span>
<span class="nc" id="L402">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L403">                return false;</span>
<span class="fc" id="L404">            }</span>
        }
<span class="nc" id="L406">        throw new IOException(&quot;Gave up waiting for server to start after &quot; + serverStartupWait.toMillis() + &quot;ms&quot;, lastCause);</span>
    }

    private boolean verifyReady() throws IOException, SQLException {
        // check TCP connection
<span class="fc" id="L411">        final InetAddress localhost = InetAddress.getLoopbackAddress();</span>
<span class="fc" id="L412">        try (Socket sock = new Socket()) {</span>
<span class="fc" id="L413">            sock.setSoTimeout((int) Duration.ofMillis(500).toMillis());</span>
<span class="fc" id="L414">            sock.connect(new InetSocketAddress(localhost, port), (int) Duration.ofMillis(500).toMillis());</span>
<span class="fc" id="L415">        } catch (ConnectException e) {</span>
<span class="fc" id="L416">            return false;</span>
<span class="fc" id="L417">        }</span>

        // check JDBC connection
<span class="fc" id="L420">        try (Connection c = createDefaultDataSource().getConnection();</span>
<span class="fc" id="L421">                Statement s = c.createStatement();</span>
<span class="fc" id="L422">                ResultSet rs = s.executeQuery(&quot;SELECT 1&quot;)) {</span>
<span class="fc" id="L423">            checkState(rs.next(), &quot;expecting single row&quot;);</span>
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">            checkState(rs.getInt(1) == 1, &quot;expecting 1 as result&quot;);</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">            checkState(!rs.next(), &quot;expecting single row&quot;);</span>
<span class="fc" id="L426">            return true;</span>
        }
    }

    private Thread newCloserThread() {
<span class="fc" id="L431">        final Thread closeThread = new Thread(() -&gt; {</span>
            try {
<span class="fc" id="L433">                EmbeddedPostgres.this.close();</span>
<span class="nc" id="L434">            } catch (IOException e) {</span>
<span class="nc" id="L435">                logger.trace(&quot;while closing instance:&quot;, e);</span>
<span class="fc" id="L436">            }</span>
<span class="fc" id="L437">        });</span>

<span class="fc" id="L439">        closeThread.setName(&quot;pg-closer&quot;);</span>
<span class="fc" id="L440">        return closeThread;</span>
    }

    /**
     * Closing an {@link EmbeddedPostgres} instance shuts down the connected database instance.
     */
    @Override
    public void close() throws IOException {
<span class="fc bfc" id="L448" title="All 2 branches covered.">        if (closed.getAndSet(true)) {</span>
<span class="fc" id="L449">            return;</span>
        }

        try {
<span class="fc" id="L453">            stopDatabase(this.dataDirectory);</span>
<span class="nc" id="L454">        } catch (final Exception e) {</span>
<span class="nc" id="L455">            logger.error(&quot;could not stop pg:&quot;, e);</span>
<span class="fc" id="L456">        }</span>

<span class="fc" id="L458">        unlock();</span>

<span class="pc bpc" id="L460" title="1 of 2 branches missed.">        if (removeDataOnShutdown) {</span>
            try {
<span class="fc" id="L462">                EmbeddedUtil.rmdirs(dataDirectory);</span>
<span class="nc" id="L463">            } catch (Exception e) {</span>
<span class="nc" id="L464">                logger.error(format(&quot;Could not clean up directory %s:&quot;, dataDirectory.getAbsolutePath()), e);</span>
<span class="pc" id="L465">            }</span>
        } else {
<span class="nc" id="L467">            logger.debug(format(&quot;preserved data directory %s&quot;, dataDirectory.getAbsolutePath()));</span>
        }
<span class="fc" id="L469">    }</span>

    @VisibleForTesting
    File getDataDirectory() {
<span class="fc" id="L473">        return dataDirectory;</span>
    }

    @VisibleForTesting
    Map&lt;String, String&gt; getLocaleConfiguration() {
<span class="fc" id="L478">        return localeConfiguration;</span>
    }


    private void cleanOldDataDirectories(File parentDirectory) {
<span class="fc" id="L483">        final File[] children = parentDirectory.listFiles();</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">        if (children == null) {</span>
<span class="nc" id="L485">            return;</span>
        }
<span class="fc bfc" id="L487" title="All 2 branches covered.">        for (final File dir : children) {</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">            if (!dir.isDirectory()) {</span>
<span class="nc" id="L489">                continue;</span>
            }

            // only ever touch known data directories.
<span class="fc bfc" id="L493" title="All 2 branches covered.">            if (!dir.getName().startsWith(DATA_DIRECTORY_PREFIX)) {</span>
<span class="fc" id="L494">                continue;</span>
            }

            // only touch data directories that hold a lock file.
<span class="fc" id="L498">            final File lockFile = new File(dir, LOCK_FILE_NAME);</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">            if (!lockFile.exists()) {</span>
<span class="fc" id="L500">                continue;</span>
            }

            // file must have a minimum age. This can not be the same check as
            // the exists b/c non-existent files return 0 (epoch) as lastModified so
            // they are considered &quot;ancient&quot;.
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">            if (System.currentTimeMillis() - lockFile.lastModified() &lt; MINIMUM_AGE_IN_MS) {</span>
<span class="fc" id="L507">                continue;</span>
            }

<span class="nc" id="L510">            try (FileOutputStream fos = new FileOutputStream(lockFile);</span>
<span class="nc" id="L511">                    FileLock lock = fos.getChannel().tryLock()) {</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">                if (lock != null) {</span>
<span class="nc" id="L513">                    logger.debug(format(&quot;found stale data directory %s&quot;, dir));</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">                    if (new File(dir, &quot;postmaster.pid&quot;).exists()) {</span>
                        try {
<span class="nc" id="L516">                            stopDatabase(dir);</span>
<span class="nc" id="L517">                            logger.debug(&quot;shutting down orphaned database!&quot;);</span>
<span class="nc" id="L518">                        } catch (Exception e) {</span>
<span class="nc" id="L519">                            logger.warn(format(&quot;failed to orphaned database in %s:&quot;, dir), e);</span>
<span class="nc" id="L520">                        }</span>
                    }
<span class="nc" id="L522">                    EmbeddedUtil.rmdirs(dir);</span>
                }
<span class="nc" id="L524">            } catch (final OverlappingFileLockException e) {</span>
                // The directory belongs to another instance in this VM.
<span class="nc" id="L526">                logger.trace(&quot;while cleaning old data directories:&quot;, e);</span>
<span class="nc" id="L527">            } catch (final Exception e) {</span>
<span class="nc" id="L528">                logger.warn(&quot;while cleaning old data directories:&quot;, e);</span>
<span class="nc" id="L529">            }</span>
        }
<span class="fc" id="L531">    }</span>

    private String pgBin(String binaryName) {
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">        final String extension = EmbeddedUtil.IS_OS_WINDOWS ? &quot;.exe&quot; : &quot;&quot;;</span>
<span class="fc" id="L535">        return new File(this.postgresInstallDirectory, &quot;bin/&quot; + binaryName + extension).getPath();</span>
    }

    private Process spawn(@Nullable String processName, List&lt;String&gt; commandAndArgs) throws IOException {
<span class="fc" id="L539">        final ProcessBuilder builder = new ProcessBuilder(commandAndArgs);</span>
<span class="fc" id="L540">        builder.redirectErrorStream(true);</span>
<span class="fc" id="L541">        builder.redirectError(errorRedirector);</span>
<span class="fc" id="L542">        builder.redirectOutput(outputRedirector);</span>
<span class="fc" id="L543">        final Process process = builder.start();</span>

<span class="pc bpc" id="L545" title="1 of 2 branches missed.">        processName = processName != null ? processName : process.info().command().map(EmbeddedUtil::getFileBaseName).orElse(&quot;&lt;unknown&gt;&quot;);</span>
<span class="fc" id="L546">        String name = format(&quot;%s (%d)&quot;, processName, process.pid());</span>

<span class="fc" id="L548">        ProcessOutputLogger.logOutput(logger, name, process);</span>
<span class="fc" id="L549">        return process;</span>
    }


    private Stopwatch system(List&lt;String&gt; commandAndArgs) throws IOException {
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">        checkArgument(commandAndArgs.size() &gt; 0, &quot;No commandAndArgs given!&quot;);</span>
<span class="fc" id="L555">        String prefix = EmbeddedUtil.getFileBaseName(commandAndArgs.get(0));</span>

<span class="fc" id="L557">        Stopwatch watch = Stopwatch.createStarted();</span>
<span class="fc" id="L558">        Process process = spawn(prefix, commandAndArgs);</span>
        try {
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">            if (process.waitFor() != 0) {</span>
<span class="nc" id="L561">                try (InputStreamReader reader = new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8)) {</span>
<span class="nc" id="L562">                    throw new IllegalStateException(format(&quot;Process %s failed%n%s&quot;,</span>
<span class="nc" id="L563">                            commandAndArgs, CharStreams.toString(reader)));</span>
                }
            }
<span class="nc" id="L566">        } catch (InterruptedException e) {</span>
<span class="nc" id="L567">            Thread.currentThread().interrupt();</span>
<span class="fc" id="L568">        }</span>

<span class="fc" id="L570">        return watch;</span>
    }


    /**
     * Callback interface to customize a builder during creation.
     *
     * @deprecated Use {@link EmbeddedPostgresPreparer} with {@link Builder} as type parameter.
     */
    @Deprecated
    @FunctionalInterface
    public interface BuilderCustomizer {

        /**
         * Callback to customize a given {@link Builder}.
         *
         * @param builder The builder instance. Any method on the builder can be called.
         * @throws SQLException For any SQL related problems.
         * @throws IOException  For any IO related problem.
         */
        void customize(@NonNull Builder builder) throws IOException, SQLException;
    }

    /**
     * Creates a new {@link EmbeddedPostgres} instance and starts it.
     */
    public static class Builder {

<span class="fc" id="L598">        private File installationBaseDirectory = null;</span>
<span class="fc" id="L599">        private File dataDirectory = null;</span>

<span class="fc" id="L601">        private final Map&lt;String, String&gt; serverConfiguration = new HashMap&lt;&gt;();</span>
<span class="fc" id="L602">        private final Map&lt;String, String&gt; localeConfiguration = new HashMap&lt;&gt;();</span>
<span class="fc" id="L603">        private boolean removeDataOnShutdown = true;</span>
<span class="fc" id="L604">        private int port = 0;</span>
<span class="fc" id="L605">        private String serverVersion = POSTGRES_VERSION;</span>
<span class="fc" id="L606">        private final Map&lt;String, String&gt; connectionProperties = new HashMap&lt;&gt;();</span>
<span class="fc" id="L607">        private NativeBinaryManager nativeBinaryManager = null;</span>
<span class="fc" id="L608">        private Duration serverStartupWait = DEFAULT_PG_STARTUP_WAIT;</span>

<span class="fc" id="L610">        private ProcessBuilder.Redirect errRedirector = ProcessBuilder.Redirect.PIPE;</span>
<span class="fc" id="L611">        private ProcessBuilder.Redirect outRedirector = ProcessBuilder.Redirect.PIPE;</span>

<span class="fc" id="L613">        Builder() {</span>
<span class="fc" id="L614">        }</span>

        /**
         * Apply a set of defaults to the database server:
         * &lt;ul&gt;
         *     &lt;li&gt;timezone: UTC&lt;/li&gt;
         *     &lt;li&gt;synchronous_commit: off&lt;/li&gt;
         *     &lt;li&gt;max_connections: 300&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * @return The builder itself.
         */
        @NonNull
        public Builder withDefaults() {
<span class="fc" id="L628">            serverConfiguration.put(&quot;timezone&quot;, &quot;UTC&quot;);</span>
<span class="fc" id="L629">            serverConfiguration.put(&quot;synchronous_commit&quot;, &quot;off&quot;);</span>
<span class="fc" id="L630">            serverConfiguration.put(&quot;max_connections&quot;, &quot;300&quot;);</span>
<span class="fc" id="L631">            return this;</span>
        }

        /**
         * Sets the time that the builder will wait for the PostgreSQL server instance to start. Default is 10 seconds.
         *
         * @param serverStartupWait Startup wait time. Must not be null or negative.
         * @return The builder itself.
         */
        @NonNull
        public Builder setServerStartupWait(@NonNull Duration serverStartupWait) {
<span class="nc" id="L642">            checkNotNull(serverStartupWait, &quot;serverStartupWait is null&quot;);</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">            checkArgument(!serverStartupWait.isNegative(), &quot;Negative durations are not permitted.&quot;);</span>

<span class="nc" id="L645">            this.serverStartupWait = serverStartupWait;</span>
<span class="nc" id="L646">            return this;</span>
        }

        /**
         * Whether to remove the data directory on server shutdown. If true, the contents of the data directory are deleted when the {@link EmbeddedPostgres}
         * instance is closed. Default is true.
         *
         * @param removeDataOnShutdown True removes the contents of the data directory on shutdown.
         * @return The builder itself.
         */
        @NonNull
        public Builder setRemoveDataOnShutdown(boolean removeDataOnShutdown) {
<span class="nc" id="L658">            this.removeDataOnShutdown = removeDataOnShutdown;</span>
<span class="nc" id="L659">            return this;</span>
        }

        /**
         * Explicitly set the location of the data directory. Default is using a managed directory.
         *
         * @param dataDirectory The directory to use. Must not be null. If it exists, the current user must be able to access the directory for reading and
         *                      writing. If the directory does not exist then the current user must be able to create it for reading and writing.
         * @return The builder itself.
         */
        @NonNull
        public Builder setDataDirectory(@NonNull Path dataDirectory) {
<span class="fc" id="L671">            checkNotNull(dataDirectory, &quot;dataDirectory is null&quot;);</span>
<span class="fc" id="L672">            return setDataDirectory(dataDirectory.toFile());</span>
        }

        /**
         * Explicitly set the location of the data directory. Default is using a managed directory.
         *
         * @param dataDirectory The directory to use. Must not be null. If it exists, the current user must be able to access the directory for reading and
         *                      writing. If the directory does not exist then the current user must be able to create it for reading and writing.
         * @return The builder itself.
         */
        @NonNull
        public Builder setDataDirectory(@NonNull String dataDirectory) {
<span class="nc" id="L684">            checkNotNull(dataDirectory, &quot;dataDirectory is null&quot;);</span>
<span class="nc" id="L685">            return setDataDirectory(new File(dataDirectory));</span>
        }

        /**
         * Explicitly set the location of the data directory. Default is using a managed directory.
         *
         * @param dataDirectory The directory to use. Must not be null. If it exists, the current user must be able to access the directory for reading and
         *                      writing. If the directory does not exist then the current user must be able to create it for reading and writing.
         * @return The builder itself.
         */
        @NonNull
        public Builder setDataDirectory(@NonNull File dataDirectory) {
<span class="fc" id="L697">            this.dataDirectory = checkNotNull(dataDirectory, &quot;dataDirectory is null&quot;);</span>
<span class="fc" id="L698">            return this;</span>
        }

        /**
         * Adds a server configuration parameter. All parameters are passed to the PostgreSQL server a startup using the &lt;code&gt;postgres&lt;/code&gt; command.
         * &lt;p&gt;
         * Values and their function are specific to the PostgreSQL version selected.
         * &lt;p&gt;
         * See &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;the PostgreSQL runtime configuration&lt;/a&gt; for more information.
         *
         * @param key   Configuration parameter name. Must not be null.
         * @param value Configuration parameter value. Must not be null.
         * @return The builder itself.
         */
        @NonNull
        public Builder addServerConfiguration(@NonNull String key, @NonNull String value) {
<span class="fc" id="L714">            checkNotNull(key, &quot;key is null&quot;);</span>
<span class="fc" id="L715">            checkNotNull(value, &quot;value is null&quot;);</span>
<span class="fc" id="L716">            this.serverConfiguration.put(key, value);</span>
<span class="fc" id="L717">            return this;</span>
        }

        /**
         * @deprecated Use {@link #addInitDbConfiguration(String, String)}.
         */
        @Deprecated
        @NonNull
        public Builder addLocaleConfiguration(@NonNull String key, @NonNull String value) {
<span class="nc" id="L726">            checkNotNull(key, &quot;key is null&quot;);</span>
<span class="nc" id="L727">            checkNotNull(value, &quot;value is null&quot;);</span>
<span class="nc" id="L728">            this.localeConfiguration.put(key, value);</span>
<span class="nc" id="L729">            return this;</span>
        }

        /**
         * Adds a configuration parameters for the &lt;code&gt;initdb&lt;/code&gt; command. The &lt;code&gt;initdb&lt;/code&gt; command is used to create the PostgreSQL server.
         * &lt;p&gt;
         * Each value is added as a command line parameter to the command.
         * &lt;p&gt;
         * See the &lt;a href=&quot;https://www.postgresql.org/docs/13/app-initdb.html&quot;&gt;PostgreSQL initdb documentation&lt;/a&gt; for an overview of possible values.
         *
         * @param key   initdb parameter name. Must not be null.
         * @param value initdb parameter value. Must not be null. When the empty string is used as the value, the resulting command line parameter will not have
         *              a equal sign and a value assigned.
         * @return The builder itself.
         */
        @NonNull
        public Builder addInitDbConfiguration(@NonNull String key, @NonNull String value) {
<span class="fc" id="L746">            checkNotNull(key, &quot;key is null&quot;);</span>
<span class="fc" id="L747">            checkNotNull(value, &quot;value is null&quot;);</span>
<span class="fc" id="L748">            this.localeConfiguration.put(key, value);</span>
<span class="fc" id="L749">            return this;</span>
        }

        /**
         * Adds a connection property. These properties are set on every connection handed out by the data source. See
         * &lt;a href=&quot;https://jdbc.postgresql.org/documentation/head/connect.html#connection-parameters&quot;&gt;the
         * PostgreSQL JDBC driver documentation&lt;/a&gt; for possible values.
         *
         * @param key   connection property name. Must not be null.
         * @param value connection property value. Must not be null.
         * @return The builder itself.
         */
        @NonNull
        public Builder addConnectionProperty(@NonNull String key, @NonNull String value) {
<span class="fc" id="L763">            checkNotNull(key, &quot;key is null&quot;);</span>
<span class="fc" id="L764">            checkNotNull(value, &quot;value is null&quot;);</span>
<span class="fc" id="L765">            this.connectionProperties.put(key, value);</span>
<span class="fc" id="L766">            return this;</span>
        }

        /**
         * Sets the directory where the PostgreSQL distribution is unpacked. Setting the installation base directory resets the {@link NativeBinaryManager} used
         * to locate the postgres installation back to the default (which is to download the zonky.io Postgres archive and unpack it in the installation
         * directory. The default is using a managed directory.
         *
         * @param installationBaseDirectory The directory to unpack the postgres distribution. The current user must be able to create and write this directory.
         *                                  Must not be null.
         * @return The builder itself.
         */
        @NonNull
        public Builder setInstallationBaseDirectory(@NonNull File installationBaseDirectory) {
<span class="nc" id="L780">            checkNotNull(installationBaseDirectory, &quot;installationBaseDirectory is null&quot;);</span>
<span class="nc" id="L781">            this.installationBaseDirectory = installationBaseDirectory;</span>
<span class="nc" id="L782">            this.nativeBinaryManager = null;</span>
<span class="nc" id="L783">            return this;</span>
        }

        /**
         * Explicitly set the TCP port for the PostgreSQL server. If the port is not available, starting the server will fail. Default is to find and use an
         * available TCP port.
         *
         * @param port The port to use. Must be &amp;gt; 1023 and &amp;lt; 65536.
         * @return The builder itself.
         */
        @NonNull
        public Builder setPort(int port) {
<span class="nc bnc" id="L795" title="All 4 branches missed.">            checkState(port &gt; 1023 &amp;&amp; port &lt; 65535, &quot;Port %s is not within 1024..65535&quot;, port);</span>
<span class="nc" id="L796">            this.port = port;</span>
<span class="nc" id="L797">            return this;</span>
        }

        /**
         * Set the version of the PostgreSQL server. This value is passed to the default binary manager which will try to resolve
         * this version from existing Maven artifacts. The value is ignored if {@link #setNativeBinaryManager(NativeBinaryManager)} is called.
         *
         * Not every PostgreSQL version is supported by pg-embedded. Some older versions lack the necessary options for the command
         * line parameters and will fail at startup. Currently, every version 10 or newer should be working.
         *
         * @param serverVersion A partial or full version. Valid values are e.g. &quot;12&quot; or &quot;11.3&quot;.
         */
        @NonNull
        public Builder setServerVersion(@NonNull String serverVersion) {
<span class="nc" id="L811">            this.serverVersion = checkNotNull(serverVersion, &quot;serverVersion is null&quot;);</span>

<span class="nc" id="L813">            return this;</span>
        }

        /**
         * Set a {@link ProcessBuilder.Redirect} instance to receive stderr output from the spawned processes.
         *
         * @param errRedirector a {@link ProcessBuilder.Redirect} instance. Must not be null.
         * @return The builder itself.
         */
        @NonNull
        public Builder setErrorRedirector(@NonNull ProcessBuilder.Redirect errRedirector) {
<span class="nc" id="L824">            this.errRedirector = checkNotNull(errRedirector, &quot;errRedirector is null&quot;);</span>
<span class="nc" id="L825">            return this;</span>
        }

        /**
         * Set a {@link ProcessBuilder.Redirect} instance to receive stdout output from the spawned processes.
         *
         * @param outRedirector a {@link ProcessBuilder.Redirect} instance. Must not be null.
         * @return The builder itself.
         */
        @NonNull
        public Builder setOutputRedirector(@NonNull ProcessBuilder.Redirect outRedirector) {
<span class="nc" id="L836">            this.outRedirector = checkNotNull(outRedirector, &quot;outRedirector is null&quot;);</span>
<span class="nc" id="L837">            return this;</span>
        }

        /**
         * Sets the {@link NativeBinaryManager} that provides the location of the postgres installation. Explicitly setting a binary manager overrides the
         * installation base directory location set with {@link #setInstallationBaseDirectory(File)} as this is only used by the default binary manager. Calling
         * {@link #setInstallationBaseDirectory(File)} after this method undoes setting the binary manager.
         *
         * @param nativeBinaryManager A {@link NativeBinaryManager} implementation. Must not be null.
         * @return The builder itself.
         */
        @NonNull
        public Builder setNativeBinaryManager(@NonNull NativeBinaryManager nativeBinaryManager) {
<span class="fc" id="L850">            this.nativeBinaryManager = checkNotNull(nativeBinaryManager, &quot;nativeBinaryManager is null&quot;);</span>
<span class="fc" id="L851">            return this;</span>
        }

        /**
         * Use a locally installed PostgreSQL server for tests. The tests will still spin up a new instance and locate the data in the data directory but it
         * will use the locally installed binaries for starting and stopping. Calling this method sets a binary manager, so it overrides {@link
         * #setNativeBinaryManager(NativeBinaryManager)}. Calling this method makes the builder ignore the {@link #setInstallationBaseDirectory(File)} setting.
         *
         * @param directory A local directory that contains a standard PostgreSQL installation. The directory must exist and read and executable.
         * @return The builder itself.
         */
        @NonNull
        public Builder useLocalPostgresInstallation(@NonNull File directory) {
<span class="fc" id="L864">            checkNotNull(directory, &quot;directory is null&quot;);</span>
<span class="pc bpc" id="L865" title="2 of 4 branches missed.">            checkState(directory.exists() &amp;&amp; directory.isDirectory(), &quot;'%s' either does not exist or is not a directory!&quot;, directory);</span>
<span class="fc" id="L866">            return setNativeBinaryManager(() -&gt; directory);</span>
        }

        /**
         * Creates and boots a new {@link EmbeddedPostgres} instance.
         *
         * @return A {@link EmbeddedPostgres} instance representing a started PostgreSQL server.
         * @throws IOException If the server could not be installed or started.
         */
        @NonNull
        public EmbeddedPostgres build() throws IOException {
            // Builder Id
<span class="fc" id="L878">            final String instanceId = EmbeddedUtil.randomAlphaNumeric(16);</span>

<span class="pc bpc" id="L880" title="1 of 2 branches missed.">            int port = this.port != 0 ? this.port : EmbeddedUtil.allocatePort();</span>

            // installation root if nothing has been set by the user.
<span class="fc" id="L883">            final File parentDirectory = EmbeddedUtil.getWorkingDirectory();</span>
<span class="fc" id="L884">            EmbeddedUtil.mkdirs(parentDirectory);</span>

<span class="fc" id="L886">            NativeBinaryManager nativeBinaryManager = this.nativeBinaryManager;</span>
<span class="fc bfc" id="L887" title="All 2 branches covered.">            if (nativeBinaryManager == null) {</span>
                // Use the parent directory if no installation directory set.
<span class="fc" id="L889">                File installationBaseDirectory = Objects.requireNonNullElse(this.installationBaseDirectory, parentDirectory);</span>
<span class="fc" id="L890">                nativeBinaryManager = new TarXzCompressedBinaryManager(installationBaseDirectory,</span>
                        EmbeddedPostgres.LOCK_FILE_NAME, new ZonkyIOPostgresLocator(serverVersion));
            }

            // this is where the binary manager actually places the unpackaged postgres installation.
<span class="fc" id="L895">            final File postgresInstallDirectory = nativeBinaryManager.getLocation();</span>

<span class="fc" id="L897">            File dataDirectory = this.dataDirectory;</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">            if (dataDirectory == null) {</span>
<span class="fc" id="L899">                dataDirectory = new File(parentDirectory, DATA_DIRECTORY_PREFIX + instanceId);</span>
            }

<span class="fc" id="L902">            EmbeddedPostgres embeddedPostgres = new EmbeddedPostgres(instanceId, postgresInstallDirectory, dataDirectory,</span>
                    removeDataOnShutdown, serverConfiguration, localeConfiguration, connectionProperties,
                    port, errRedirector, outRedirector,
                    serverStartupWait);

<span class="fc" id="L907">            embeddedPostgres.cleanOldDataDirectories(parentDirectory);</span>

<span class="fc" id="L909">            embeddedPostgres.boot();</span>

<span class="fc" id="L911">            return embeddedPostgres;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>