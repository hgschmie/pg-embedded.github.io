<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EmbeddedPostgres.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pg-embedded</a> &gt; <a href="index.source.html" class="el_package">de.softwareforge.testing.postgres.embedded</a> &gt; <span class="el_source">EmbeddedPostgres.java</span></div><h1>EmbeddedPostgres.java</h1><pre class="source lang-java linenums">/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package de.softwareforge.testing.postgres.embedded;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;
import static de.softwareforge.testing.postgres.embedded.DatabaseInfo.PG_DEFAULT_DB;
import static de.softwareforge.testing.postgres.embedded.DatabaseInfo.PG_DEFAULT_USER;
import static de.softwareforge.testing.postgres.embedded.EmbeddedUtil.formatDuration;
import static java.lang.String.format;
import static java.nio.file.StandardOpenOption.CREATE;
import static java.nio.file.StandardOpenOption.DELETE_ON_CLOSE;
import static java.nio.file.StandardOpenOption.TRUNCATE_EXISTING;
import static java.nio.file.StandardOpenOption.WRITE;

import de.softwareforge.testing.postgres.embedded.ProcessOutputLogger.StreamCapture;

import jakarta.annotation.Nonnull;
import jakarta.annotation.Nullable;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.ProcessBuilder.Redirect;
import java.net.ConnectException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.channels.OverlappingFileLockException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.Duration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.sql.DataSource;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Joiner;
import com.google.common.base.Stopwatch;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.io.CharStreams;
import com.google.common.io.Closeables;
import org.postgresql.ds.PGSimpleDataSource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Manages an embedded PostgreSQL server instance.
 */
public final class EmbeddedPostgres implements AutoCloseable {

    /**
     * The version of postgres used if no specific version has been given.
     */
    public static final String DEFAULT_POSTGRES_VERSION = &quot;15&quot;;

<span class="fc" id="L83">    static final String[] LOCALHOST_SERVER_NAMES = {&quot;localhost&quot;};</span>

    private static final String PG_TEMPLATE_DB = &quot;template1&quot;;

    @VisibleForTesting
<span class="fc" id="L88">    static final Duration DEFAULT_PG_STARTUP_WAIT = Duration.ofSeconds(10);</span>

    // folders need to be at least 10 minutes old to be considered for deletion.
<span class="fc" id="L91">    private static final long MINIMUM_AGE_IN_MS = Duration.ofMinutes(10).toMillis();</span>

    // prefix for data folders in the parent that might be deleted
    private static final String DATA_DIRECTORY_PREFIX = &quot;data-&quot;;

    private static final String PG_STOP_MODE = &quot;fast&quot;;
    private static final String PG_STOP_WAIT_SECONDS = &quot;5&quot;;
    static final String LOCK_FILE_NAME = &quot;epg-lock&quot;;

    @SuppressWarnings(&quot;PMD.ProperLogger&quot;)
    private final Logger logger;

    private final String instanceId;
    private final File postgresInstallDirectory;
    private final File dataDirectory;

    private final Duration serverStartupWait;
    private final int port;
<span class="fc" id="L109">    private final AtomicBoolean started = new AtomicBoolean();</span>
<span class="fc" id="L110">    private final AtomicBoolean closed = new AtomicBoolean();</span>

    private final ImmutableMap&lt;String, String&gt; serverConfiguration;
    private final ImmutableMap&lt;String, String&gt; localeConfiguration;
    private final ImmutableMap&lt;String, String&gt; connectionProperties;

    private final File lockFile;
    private volatile FileChannel lockChannel;
    private volatile FileLock lock;

    private final boolean removeDataOnShutdown;

    private final ProcessBuilder.Redirect errorRedirector;
    private final ProcessBuilder.Redirect outputRedirector;
    private final ProcessOutputLogger pgServerLogger;


    /**
     * Returns an instance that has been started and configured. The {@link Builder#withDefaults()} configuration has been applied.
     */
    @Nonnull
    public static EmbeddedPostgres defaultInstance() throws IOException {
<span class="fc" id="L132">        return builderWithDefaults().build();</span>
    }

    /**
     * Returns a builder with default {@link Builder#withDefaults()} configuration already applied.
     */
    @Nonnull
    public static EmbeddedPostgres.Builder builderWithDefaults() {
<span class="fc" id="L140">        return new Builder().withDefaults();</span>
    }

    /**
     * This returns an {@link EmbeddedPostgres} instance that can be solely used for version checking. It has not been booted and will not work for any other
     * things but executing {@link EmbeddedPostgres#getPostgresVersion()}. This is a performance optimization for code that needs to do version checking and
     * does not want to pay the penalty of spinning up and shutting down an instance.
     *
     * @return An unstarted {@link EmbeddedPostgres} instance.
     * @throws IOException Could not create the instance.
     * @since 4.1
     */
    public static EmbeddedPostgres forVersionCheck() throws IOException {
<span class="fc" id="L153">        return new Builder(false).build();</span>
    }

    /**
     * Returns a new {@link Builder}.
     */
    @Nonnull
    public static EmbeddedPostgres.Builder builder() {
<span class="fc" id="L161">        return new Builder();</span>
    }

    private EmbeddedPostgres(
            final String instanceId,
            final File postgresInstallDirectory,
            final File dataDirectory,
            final boolean removeDataOnShutdown,
            final Map&lt;String, String&gt; serverConfiguration,
            final Map&lt;String, String&gt; localeConfiguration,
            final Map&lt;String, String&gt; connectionProperties,
            final int port,
            final ProcessBuilder.Redirect errorRedirector,
            final ProcessBuilder.Redirect outputRedirector,
<span class="fc" id="L175">            final Duration serverStartupWait) {</span>

<span class="fc" id="L177">        this.instanceId = checkNotNull(instanceId, &quot;instanceId is null&quot;);</span>

<span class="fc" id="L179">        this.logger = LoggerFactory.getLogger(toString());</span>
<span class="fc" id="L180">        this.pgServerLogger = new ProcessOutputLogger(logger);</span>

<span class="fc" id="L182">        this.postgresInstallDirectory = checkNotNull(postgresInstallDirectory, &quot;postgresInstallDirectory is null&quot;);</span>
<span class="fc" id="L183">        this.dataDirectory = checkNotNull(dataDirectory, &quot;dataDirectory is null&quot;);</span>

<span class="fc" id="L185">        this.removeDataOnShutdown = removeDataOnShutdown;</span>

<span class="fc" id="L187">        this.serverConfiguration = ImmutableMap.copyOf(checkNotNull(serverConfiguration, &quot;serverConfiguration is null&quot;));</span>
<span class="fc" id="L188">        this.localeConfiguration = ImmutableMap.copyOf(checkNotNull(localeConfiguration, &quot;localeConfiguration is null&quot;));</span>
<span class="fc" id="L189">        this.connectionProperties = ImmutableMap.copyOf(checkNotNull(connectionProperties, &quot;connectionProperties is null&quot;));</span>

<span class="fc" id="L191">        this.port = port;</span>

<span class="fc" id="L193">        this.errorRedirector = checkNotNull(errorRedirector, &quot;errorRedirector is null&quot;);</span>
<span class="fc" id="L194">        this.outputRedirector = checkNotNull(outputRedirector, &quot;outputRedirector is null&quot;);</span>

<span class="fc" id="L196">        this.serverStartupWait = checkNotNull(serverStartupWait, &quot;serverStartupWait is null&quot;);</span>
<span class="fc" id="L197">        this.lockFile = new File(this.dataDirectory, LOCK_FILE_NAME);</span>

<span class="fc" id="L199">        logger.debug(format(&quot;data dir is %s, install dir is %s&quot;, this.dataDirectory, this.postgresInstallDirectory));</span>
<span class="fc" id="L200">    }</span>

    /**
     * Creates a {@link DataSource} object that connects to the standard system database.
     * &lt;p&gt;
     * The standard system database is the &lt;code&gt;template1&lt;/code&gt; database.
     * &lt;p&gt;
     * Any modification to this database will be propagated to any new database that is created with &lt;code&gt;CREATE DATABASE...&lt;/code&gt; unless another database is
     * explicitly named as the template..
     */
    @Nonnull
    public DataSource createTemplateDataSource() throws SQLException {
<span class="fc" id="L212">        checkState(started.get(), &quot;instance has not been started!&quot;);</span>

<span class="fc" id="L214">        return createDataSource(PG_DEFAULT_USER, PG_TEMPLATE_DB, getPort(), getConnectionProperties());</span>
    }

    /**
     * Creates a {@link DataSource} object that connects to the default database.
     * &lt;p&gt;
     * The default database is the &lt;code&gt;postgres&lt;/code&gt; database.
     */
    @Nonnull
    public DataSource createDefaultDataSource() throws SQLException {
<span class="fc" id="L224">        checkState(started.get(), &quot;instance has not been started!&quot;);</span>

<span class="fc" id="L226">        return createDataSource(PG_DEFAULT_USER, PG_DEFAULT_DB, getPort(), getConnectionProperties());</span>
    }

    /**
     * Creates a {@link DataSource} with a specific user and database name.
     * &lt;p&gt;
     * Creating the DataSource does &lt;b&gt;not&lt;/b&gt; create the database or the user itself. This must be done by the calling code (e.g. with a
     * {@link EmbeddedPostgresPreparer}).
     */
    @Nonnull
    public DataSource createDataSource(@Nonnull String user, @Nonnull String databaseName) throws SQLException {
<span class="nc" id="L237">        checkState(started.get(), &quot;instance has not been started!&quot;);</span>

<span class="nc" id="L239">        return createDataSource(user, databaseName, getPort(), getConnectionProperties());</span>
    }

    static DataSource createDataSource(String user, String databaseName, int port, Map&lt;String, String&gt; connectionProperties) throws SQLException {
<span class="fc" id="L243">        checkNotNull(user, &quot;user is null&quot;);</span>
<span class="fc" id="L244">        checkNotNull(databaseName, &quot;databaseName is null&quot;);</span>
<span class="fc" id="L245">        checkNotNull(connectionProperties, &quot;connectionProperties is null&quot;);</span>

<span class="fc" id="L247">        final PGSimpleDataSource ds = new PGSimpleDataSource();</span>

<span class="fc" id="L249">        ds.setServerNames(LOCALHOST_SERVER_NAMES);</span>
<span class="fc" id="L250">        ds.setPortNumbers(new int[]{port});</span>
<span class="fc" id="L251">        ds.setDatabaseName(databaseName);</span>
<span class="fc" id="L252">        ds.setUser(user);</span>

<span class="fc bfc" id="L254" title="All 2 branches covered.">        for (final Entry&lt;String, String&gt; entry : connectionProperties.entrySet()) {</span>
<span class="fc" id="L255">            ds.setProperty(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L256">        }</span>

<span class="fc" id="L258">        return ds;</span>
    }

    /**
     * Returns the network (TCP) port for the PostgreSQL server instance.
     */
    public int getPort() {
<span class="fc" id="L265">        checkState(started.get(), &quot;instance has not been started!&quot;);</span>

<span class="fc" id="L267">        return port;</span>
    }

    /**
     * Returns the connection properties for the PostgreSQL server instance.
     */
    @Nonnull
    ImmutableMap&lt;String, String&gt; getConnectionProperties() {
<span class="fc" id="L275">        checkState(started.get(), &quot;instance has not been started!&quot;);</span>

<span class="fc" id="L277">        return connectionProperties;</span>
    }

    /**
     * Returns the instance id for the PostgreSQL server instance. This id is an alphanumeric string that can be used to differentiate between multiple embedded
     * PostgreSQL server instances.
     */
    @Nonnull
    public String instanceId() {
<span class="fc" id="L286">        checkState(started.get(), &quot;instance has not been started!&quot;);</span>

<span class="fc" id="L288">        return instanceId;</span>
    }

    /**
     * Return the version of the PostgreSQL installation that is used by this instance.
     *
     * @return A string representing the Postgres version as described in the &lt;a href=&quot;https://www.postgresql.org/support/versioning/&quot;&gt;Postgres versioning
     * policy&lt;/a&gt;.
     * @since 4.1
     */
    public String getPostgresVersion() throws IOException {

<span class="fc" id="L300">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L301">        StreamCapture logCapture = pgServerLogger.captureStreamAsConsumer(sb::append);</span>

<span class="fc" id="L303">        List&lt;String&gt; commandAndArgs = ImmutableList.of(pgBin(&quot;pg_ctl&quot;), &quot;--version&quot;);</span>
<span class="fc" id="L304">        final Stopwatch watch = system(commandAndArgs, logCapture);</span>

<span class="fc" id="L306">        String version = &quot;unknown&quot;;</span>

        try {
<span class="fc" id="L309">            logCapture.getCompletion().get();</span>
<span class="fc" id="L310">            final String s = sb.toString();</span>
<span class="fc" id="L311">            checkState(s.startsWith(&quot;pg_ctl &quot;), &quot;Response %s does not match 'pg_ctl'&quot;, sb);</span>
<span class="fc" id="L312">            version = s.substring(s.lastIndexOf(' ')).trim();</span>

<span class="nc" id="L314">        } catch (ExecutionException e) {</span>
<span class="nc" id="L315">            throw new IOException(format(&quot;Process '%s' failed%n&quot;, Joiner.on(&quot; &quot;).join(commandAndArgs)), e);</span>
<span class="nc" id="L316">        } catch (InterruptedException e) {</span>
<span class="nc" id="L317">            Thread.currentThread().interrupt();</span>
<span class="fc" id="L318">        }</span>

<span class="fc" id="L320">        logger.debug(format(&quot;postgres version check completed in %s&quot;, formatDuration(watch.elapsed())));</span>
<span class="fc" id="L321">        return version;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L326">        return this.getClass().getName() + &quot;$&quot; + this.instanceId;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L331" title="All 2 branches missed.">        if (this == o) {</span>
<span class="nc" id="L332">            return true;</span>
        }
<span class="nc bnc" id="L334" title="All 4 branches missed.">        if (o == null || getClass() != o.getClass()) {</span>
<span class="nc" id="L335">            return false;</span>
        }
<span class="nc" id="L337">        EmbeddedPostgres that = (EmbeddedPostgres) o;</span>
<span class="nc" id="L338">        return instanceId.equals(that.instanceId);</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L343">        return Objects.hash(instanceId);</span>
    }

    // internal methods
    DatabaseInfo createDefaultDatabaseInfo() {
<span class="fc" id="L348">        return DatabaseInfo.builder().port(getPort()).connectionProperties(getConnectionProperties()).build();</span>
    }


    private void boot() throws IOException {
<span class="fc" id="L353">        EmbeddedUtil.ensureDirectory(this.dataDirectory);</span>

<span class="pc bpc" id="L355" title="3 of 4 branches missed.">        if (this.removeDataOnShutdown || !new File(this.dataDirectory, &quot;postgresql.conf&quot;).exists()) {</span>
<span class="fc" id="L356">            initDatabase();</span>
        }

<span class="fc" id="L359">        lock();</span>

<span class="fc" id="L361">        startDatabase();</span>
<span class="fc" id="L362">    }</span>


    private synchronized void lock() throws IOException {
<span class="fc" id="L366">        this.lockChannel = FileChannel.open(this.lockFile.toPath(), CREATE, WRITE, TRUNCATE_EXISTING);</span>
<span class="fc" id="L367">        this.lock = this.lockChannel.tryLock();</span>
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">        checkState(lock != null, &quot;could not lock %s&quot;, lockFile);</span>
<span class="fc" id="L369">    }</span>

    private synchronized void unlock() throws IOException {
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (lock != null) {</span>
<span class="fc" id="L373">            lock.release();</span>
        }
<span class="fc" id="L375">        Closeables.close(this.lockChannel, true);</span>
<span class="fc" id="L376">        Files.deleteIfExists(this.lockFile.toPath());</span>
<span class="fc" id="L377">    }</span>

    private void initDatabase() throws IOException {
<span class="fc" id="L380">        ImmutableList.Builder&lt;String&gt; commandBuilder = ImmutableList.builder();</span>
<span class="fc" id="L381">        commandBuilder.add(pgBin(&quot;initdb&quot;))</span>
<span class="fc" id="L382">                .addAll(createInitDbOptions())</span>
<span class="fc" id="L383">                .add(&quot;-A&quot;, &quot;trust&quot;,</span>
                        &quot;-U&quot;, PG_DEFAULT_USER,
<span class="fc" id="L385">                        &quot;-D&quot;, this.dataDirectory.getPath(),</span>
                        &quot;-E&quot;, &quot;UTF-8&quot;);
<span class="fc" id="L387">        final Stopwatch watch = system(commandBuilder.build(), pgServerLogger.captureStreamAsLog());</span>
<span class="fc" id="L388">        logger.debug(format(&quot;initdb completed in %s&quot;, formatDuration(watch.elapsed())));</span>
<span class="fc" id="L389">    }</span>

    private void startDatabase() throws IOException {
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">        checkState(!started.getAndSet(true), &quot;database already started!&quot;);</span>

<span class="fc" id="L394">        final ImmutableList.Builder&lt;String&gt; commandBuilder = ImmutableList.builder();</span>
<span class="fc" id="L395">        commandBuilder.add(pgBin(&quot;pg_ctl&quot;),</span>
<span class="fc" id="L396">                &quot;-D&quot;, this.dataDirectory.getPath(),</span>
<span class="fc" id="L397">                &quot;-o&quot;, String.join(&quot; &quot;, createInitOptions()),</span>
                &quot;start&quot;
        );

<span class="fc" id="L401">        final Stopwatch watch = Stopwatch.createStarted();</span>
<span class="fc" id="L402">        final Process postmaster = spawn(&quot;pg&quot;, commandBuilder.build(), pgServerLogger.captureStreamAsLog());</span>

<span class="fc" id="L404">        logger.info(format(&quot;started as pid %d on port %d&quot;, postmaster.pid(), port));</span>
<span class="fc" id="L405">        logger.debug(format(&quot;Waiting up to %s for server startup to finish&quot;, formatDuration(serverStartupWait)));</span>

<span class="fc" id="L407">        Runtime.getRuntime().addShutdownHook(newCloserThread());</span>

<span class="fc" id="L409">        checkState(waitForServerStartup(), &quot;Could not start PostgreSQL server, interrupted?&quot;);</span>
<span class="fc" id="L410">        logger.debug(format(&quot;startup complete in %s&quot;, formatDuration(watch.elapsed())));</span>
<span class="fc" id="L411">    }</span>

    private void stopDatabase(File dataDirectory) throws IOException {
<span class="fc bfc" id="L414" title="All 2 branches covered.">        if (started.get()) {</span>
<span class="fc" id="L415">            final ImmutableList.Builder&lt;String&gt; commandBuilder = ImmutableList.builder();</span>
<span class="fc" id="L416">            commandBuilder.add(pgBin(&quot;pg_ctl&quot;),</span>
<span class="fc" id="L417">                    &quot;-D&quot;, dataDirectory.getPath(),</span>
                    &quot;stop&quot;,
                    &quot;-m&quot;, PG_STOP_MODE,
                    &quot;-t&quot;, PG_STOP_WAIT_SECONDS, &quot;-w&quot;);

<span class="fc" id="L422">            final Stopwatch watch = system(commandBuilder.build(), pgServerLogger.captureStreamAsLog());</span>
<span class="fc" id="L423">            logger.debug(format(&quot;shutdown complete in %s&quot;, formatDuration(watch.elapsed())));</span>
        }
<span class="fc" id="L425">        pgServerLogger.close();</span>
<span class="fc" id="L426">    }</span>

    private List&lt;String&gt; createInitOptions() {
<span class="fc" id="L429">        final ImmutableList.Builder&lt;String&gt; initOptions = ImmutableList.builder();</span>
<span class="fc" id="L430">        initOptions.add(</span>
<span class="fc" id="L431">                &quot;-p&quot;, Integer.toString(port),</span>
                &quot;-F&quot;);

<span class="fc" id="L434">        serverConfiguration.forEach((key, value) -&gt; {</span>
<span class="fc" id="L435">            initOptions.add(&quot;-c&quot;);</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">            if (!value.isEmpty()) {</span>
<span class="fc" id="L437">                initOptions.add(key + &quot;=&quot; + value);</span>
            } else {
<span class="nc" id="L439">                initOptions.add(key + &quot;=true&quot;);</span>
            }
<span class="fc" id="L441">        });</span>

<span class="fc" id="L443">        return initOptions.build();</span>
    }

    @VisibleForTesting
    List&lt;String&gt; createInitDbOptions() {
<span class="fc" id="L448">        final ImmutableList.Builder&lt;String&gt; localeOptions = ImmutableList.builder();</span>

<span class="fc" id="L450">        localeConfiguration.forEach((key, value) -&gt; {</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">            if (!value.isEmpty()) {</span>
<span class="fc" id="L452">                localeOptions.add(&quot;--&quot; + key + &quot;=&quot; + value);</span>
            } else {
<span class="fc" id="L454">                localeOptions.add(&quot;--&quot; + key);</span>
            }
<span class="fc" id="L456">        });</span>
<span class="fc" id="L457">        return localeOptions.build();</span>
    }

    private boolean waitForServerStartup() throws IOException {
<span class="fc" id="L461">        Throwable lastCause = null;</span>
<span class="fc" id="L462">        final long start = System.nanoTime();</span>
<span class="fc" id="L463">        final long maxWaitNs = TimeUnit.NANOSECONDS.convert(serverStartupWait.toMillis(), TimeUnit.MILLISECONDS);</span>
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">        while (System.nanoTime() - start &lt; maxWaitNs) {</span>
            try {
<span class="fc bfc" id="L466" title="All 2 branches covered.">                if (verifyReady()) {</span>
<span class="fc" id="L467">                    return true;</span>
                }
<span class="nc" id="L469">            } catch (final SQLException e) {</span>
<span class="nc" id="L470">                lastCause = e;</span>
<span class="nc" id="L471">                logger.trace(&quot;while waiting for server startup:&quot;, e);</span>
<span class="fc" id="L472">            }</span>

            try {
<span class="fc" id="L475">                Thread.sleep(100);</span>
<span class="nc" id="L476">            } catch (final InterruptedException e) {</span>
<span class="nc" id="L477">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L478">                return false;</span>
<span class="fc" id="L479">            }</span>
        }
<span class="nc" id="L481">        throw new IOException(&quot;Gave up waiting for server to start after &quot; + serverStartupWait.toMillis() + &quot;ms&quot;, lastCause);</span>
    }

    @SuppressWarnings(&quot;PMD.CheckResultSet&quot;) // see https://github.com/pmd/pmd/issues/5209 / https://github.com/pmd/pmd/issues/5031
    private boolean verifyReady() throws IOException, SQLException {
        // check TCP connection
<span class="fc" id="L487">        final InetAddress localhost = InetAddress.getLoopbackAddress();</span>
<span class="fc" id="L488">        try (Socket sock = new Socket()) {</span>
<span class="fc" id="L489">            sock.setSoTimeout((int) Duration.ofMillis(500).toMillis());</span>
<span class="fc" id="L490">            sock.connect(new InetSocketAddress(localhost, port), (int) Duration.ofMillis(500).toMillis());</span>
<span class="fc" id="L491">        } catch (ConnectException e) {</span>
<span class="fc" id="L492">            return false;</span>
<span class="fc" id="L493">        }</span>

        // check JDBC connection
<span class="fc" id="L496">        try (Connection c = createDefaultDataSource().getConnection();</span>
<span class="fc" id="L497">                Statement s = c.createStatement();</span>
<span class="fc" id="L498">                ResultSet rs = s.executeQuery(&quot;SELECT 1&quot;)) {</span>
<span class="fc" id="L499">            checkState(rs.next(), &quot;expecting single row&quot;);</span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">            checkState(rs.getInt(1) == 1, &quot;expecting 1 as result&quot;);</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">            checkState(!rs.next(), &quot;expecting single row&quot;);</span>
<span class="fc" id="L502">            return true;</span>
        }
    }

    private Thread newCloserThread() {
<span class="fc" id="L507">        final Thread closeThread = new Thread(() -&gt; {</span>
            try {
<span class="fc" id="L509">                this.close();</span>
<span class="nc" id="L510">            } catch (IOException e) {</span>
<span class="nc" id="L511">                logger.trace(&quot;while closing instance:&quot;, e);</span>
<span class="fc" id="L512">            }</span>
<span class="fc" id="L513">        });</span>

<span class="fc" id="L515">        closeThread.setName(&quot;pg-closer&quot;);</span>
<span class="fc" id="L516">        return closeThread;</span>
    }

    /**
     * Closing an {@link EmbeddedPostgres} instance shuts down the connected database instance.
     */
    @Override
    public void close() throws IOException {
<span class="fc bfc" id="L524" title="All 2 branches covered.">        if (closed.getAndSet(true)) {</span>
<span class="fc" id="L525">            return;</span>
        }

        try {
<span class="fc" id="L529">            stopDatabase(this.dataDirectory);</span>
<span class="nc" id="L530">        } catch (final Exception e) {</span>
<span class="nc" id="L531">            logger.error(&quot;could not stop pg:&quot;, e);</span>
<span class="fc" id="L532">        }</span>

<span class="fc" id="L534">        unlock();</span>

<span class="pc bpc" id="L536" title="1 of 2 branches missed.">        if (removeDataOnShutdown) {</span>
            try {
<span class="fc" id="L538">                EmbeddedUtil.rmdirs(dataDirectory);</span>
<span class="nc" id="L539">            } catch (Exception e) {</span>
<span class="nc" id="L540">                logger.error(format(&quot;Could not clean up directory %s:&quot;, dataDirectory.getAbsolutePath()), e);</span>
<span class="pc" id="L541">            }</span>
        } else {
<span class="nc" id="L543">            logger.debug(format(&quot;preserved data directory %s&quot;, dataDirectory.getAbsolutePath()));</span>
        }
<span class="fc" id="L545">    }</span>

    @VisibleForTesting
    File getDataDirectory() {
<span class="fc" id="L549">        return dataDirectory;</span>
    }

    @VisibleForTesting
    Map&lt;String, String&gt; getLocaleConfiguration() {
<span class="fc" id="L554">        return localeConfiguration;</span>
    }


    private void cleanOldDataDirectories(File parentDirectory) {
<span class="fc" id="L559">        final File[] children = parentDirectory.listFiles();</span>
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">        if (children == null) {</span>
<span class="nc" id="L561">            return;</span>
        }
<span class="fc bfc" id="L563" title="All 2 branches covered.">        for (final File dir : children) {</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">            if (!dir.isDirectory()) {</span>
<span class="nc" id="L565">                continue;</span>
            }

            // only ever touch known data directories.
<span class="fc bfc" id="L569" title="All 2 branches covered.">            if (!dir.getName().startsWith(DATA_DIRECTORY_PREFIX)) {</span>
<span class="fc" id="L570">                continue;</span>
            }

            // only touch data directories that hold a lock file.
<span class="fc" id="L574">            final File lockFile = new File(dir, LOCK_FILE_NAME);</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">            if (!lockFile.exists()) {</span>
<span class="fc" id="L576">                continue;</span>
            }

            // file must have a minimum age. This can not be the same check as
            // the exists b/c non-existent files return 0 (epoch) as lastModified so
            // they are considered &quot;ancient&quot;.
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">            if (System.currentTimeMillis() - lockFile.lastModified() &lt; MINIMUM_AGE_IN_MS) {</span>
<span class="fc" id="L583">                continue;</span>
            }

<span class="nc" id="L586">            try (FileChannel fileChannel = FileChannel.open(lockFile.toPath(), CREATE, WRITE, TRUNCATE_EXISTING, DELETE_ON_CLOSE);</span>
<span class="nc" id="L587">                    FileLock lock = fileChannel.tryLock()) {</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">                if (lock != null) {</span>
<span class="nc" id="L589">                    logger.debug(format(&quot;found stale data directory %s&quot;, dir));</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">                    if (new File(dir, &quot;postmaster.pid&quot;).exists()) {</span>
                        try {
<span class="nc" id="L592">                            stopDatabase(dir);</span>
<span class="nc" id="L593">                            logger.debug(&quot;shutting down orphaned database!&quot;);</span>
<span class="nc" id="L594">                        } catch (Exception e) {</span>
<span class="nc" id="L595">                            logger.warn(format(&quot;failed to orphaned database in %s:&quot;, dir), e);</span>
<span class="nc" id="L596">                        }</span>
                    }
<span class="nc" id="L598">                    EmbeddedUtil.rmdirs(dir);</span>
                }
<span class="nc" id="L600">            } catch (final OverlappingFileLockException e) {</span>
                // The directory belongs to another instance in this VM.
<span class="nc" id="L602">                logger.trace(&quot;while cleaning old data directories:&quot;, e);</span>
<span class="nc" id="L603">            } catch (final IOException e) {</span>
<span class="nc" id="L604">                logger.warn(&quot;while cleaning old data directories:&quot;, e);</span>
<span class="nc" id="L605">            }</span>
        }
<span class="fc" id="L607">    }</span>

    private String pgBin(String binaryName) {
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">        final String extension = EmbeddedUtil.IS_OS_WINDOWS ? &quot;.exe&quot; : &quot;&quot;;</span>
<span class="fc" id="L611">        return new File(this.postgresInstallDirectory, &quot;bin/&quot; + binaryName + extension).getPath();</span>
    }

    private Process spawn(@Nullable String processName, List&lt;String&gt; commandAndArgs,
            StreamCapture logCapture)
            throws IOException {
<span class="fc" id="L617">        final ProcessBuilder builder = new ProcessBuilder(commandAndArgs);</span>
<span class="fc" id="L618">        builder.redirectErrorStream(true);</span>
<span class="fc" id="L619">        builder.redirectError(errorRedirector);</span>
<span class="fc" id="L620">        builder.redirectOutput(outputRedirector);</span>
<span class="fc" id="L621">        final Process process = builder.start();</span>

<span class="pc bpc" id="L623" title="1 of 2 branches missed.">        if (outputRedirector == Redirect.PIPE) {</span>
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">            processName = processName != null ? processName : process.info().command().map(EmbeddedUtil::getFileBaseName).orElse(&quot;&lt;unknown&gt;&quot;);</span>
<span class="fc" id="L625">            String name = format(&quot;%s (%d)&quot;, processName, process.pid());</span>
<span class="fc" id="L626">            logCapture.accept(name, process.getInputStream());</span>
        }
<span class="fc" id="L628">        return process;</span>
    }

    private Stopwatch system(List&lt;String&gt; commandAndArgs, StreamCapture logCapture) throws IOException {
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">        checkArgument(!commandAndArgs.isEmpty(), &quot;No commandAndArgs given!&quot;);</span>
<span class="fc" id="L633">        String prefix = EmbeddedUtil.getFileBaseName(commandAndArgs.get(0));</span>

<span class="fc" id="L635">        Stopwatch watch = Stopwatch.createStarted();</span>
        try {
<span class="fc" id="L637">            Process process = spawn(prefix, commandAndArgs, logCapture);</span>
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">            if (process.waitFor() != 0) {</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">                if (errorRedirector == Redirect.PIPE) {</span>
<span class="nc" id="L640">                    try (InputStreamReader errorReader = new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8)) {</span>
<span class="nc" id="L641">                        throw new IOException(format(&quot;Process '%s' failed%n%s&quot;, Joiner.on(&quot; &quot;).join(commandAndArgs), CharStreams.toString(errorReader)));</span>
                    }
                } else {
<span class="nc" id="L644">                    throw new IOException(format(&quot;Process '%s' failed&quot;,</span>
<span class="nc" id="L645">                            Joiner.on(&quot; &quot;).join(commandAndArgs)));</span>
                }
            }
<span class="nc" id="L648">        } catch (InterruptedException e) {</span>
<span class="nc" id="L649">            Thread.currentThread().interrupt();</span>
<span class="fc" id="L650">        }</span>

<span class="fc" id="L652">        return watch;</span>
    }

    /**
     * Creates a new {@link EmbeddedPostgres} instance and starts it.
     */
    public static class Builder {

<span class="fc" id="L660">        private File installationBaseDirectory = null;</span>
<span class="fc" id="L661">        private File dataDirectory = null;</span>

<span class="fc" id="L663">        private final Map&lt;String, String&gt; serverConfiguration = new HashMap&lt;&gt;();</span>
<span class="fc" id="L664">        private final Map&lt;String, String&gt; localeConfiguration = new HashMap&lt;&gt;();</span>
<span class="fc" id="L665">        private boolean removeDataOnShutdown = true;</span>
<span class="fc" id="L666">        private int port = 0;</span>
<span class="fc" id="L667">        private String serverVersion = DEFAULT_POSTGRES_VERSION;</span>
<span class="fc" id="L668">        private final Map&lt;String, String&gt; connectionProperties = new HashMap&lt;&gt;();</span>
<span class="fc" id="L669">        private NativeBinaryManager nativeBinaryManager = null;</span>
<span class="fc" id="L670">        private Duration serverStartupWait = DEFAULT_PG_STARTUP_WAIT;</span>

<span class="fc" id="L672">        private ProcessBuilder.Redirect errorRedirector = ProcessBuilder.Redirect.PIPE;</span>
<span class="fc" id="L673">        private ProcessBuilder.Redirect outputRedirector = ProcessBuilder.Redirect.PIPE;</span>

        private final boolean bootInstance;

<span class="fc" id="L677">        private Builder(boolean bootInstance) {</span>
<span class="fc" id="L678">            this.bootInstance = bootInstance;</span>
<span class="fc" id="L679">        }</span>

        Builder() {
<span class="fc" id="L682">            this(true);</span>
<span class="fc" id="L683">        }</span>

        /**
         * Apply a set of defaults to the database server:
         * &lt;ul&gt;
         *     &lt;li&gt;timezone: UTC&lt;/li&gt;
         *     &lt;li&gt;synchronous_commit: off&lt;/li&gt;
         *     &lt;li&gt;max_connections: 300&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * @return The builder itself.
         */
        @Nonnull
        public Builder withDefaults() {
<span class="fc" id="L697">            serverConfiguration.put(&quot;timezone&quot;, &quot;UTC&quot;);</span>
<span class="fc" id="L698">            serverConfiguration.put(&quot;synchronous_commit&quot;, &quot;off&quot;);</span>
<span class="fc" id="L699">            serverConfiguration.put(&quot;max_connections&quot;, &quot;300&quot;);</span>
<span class="fc" id="L700">            return this;</span>
        }

        /**
         * Sets the time that the builder will wait for the PostgreSQL server instance to start. Default is 10 seconds.
         *
         * @param serverStartupWait Startup wait time. Must not be null or negative.
         * @return The builder itself.
         */
        @Nonnull
        public Builder setServerStartupWait(@Nonnull Duration serverStartupWait) {
<span class="nc" id="L711">            checkNotNull(serverStartupWait, &quot;serverStartupWait is null&quot;);</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">            checkArgument(!serverStartupWait.isNegative(), &quot;Negative durations are not permitted.&quot;);</span>

<span class="nc" id="L714">            this.serverStartupWait = serverStartupWait;</span>
<span class="nc" id="L715">            return this;</span>
        }

        /**
         * Whether to remove the data directory on server shutdown. If true, the contents of the data directory are deleted when the {@link EmbeddedPostgres}
         * instance is closed. Default is true.
         *
         * @param removeDataOnShutdown True removes the contents of the data directory on shutdown.
         * @return The builder itself.
         */
        @Nonnull
        public Builder setRemoveDataOnShutdown(boolean removeDataOnShutdown) {
<span class="nc" id="L727">            this.removeDataOnShutdown = removeDataOnShutdown;</span>
<span class="nc" id="L728">            return this;</span>
        }

        /**
         * Explicitly set the location of the data directory. Default is using a managed directory.
         *
         * @param dataDirectory The directory to use. Must not be null. If it exists, the current user must be able to access the directory for reading and
         *                      writing. If the directory does not exist then the current user must be able to create it for reading and writing.
         * @return The builder itself.
         */
        @Nonnull
        public Builder setDataDirectory(@Nonnull Path dataDirectory) {
<span class="fc" id="L740">            checkNotNull(dataDirectory, &quot;dataDirectory is null&quot;);</span>
<span class="fc" id="L741">            return setDataDirectory(dataDirectory.toFile());</span>
        }

        /**
         * Explicitly set the location of the data directory. Default is using a managed directory.
         *
         * @param dataDirectory The directory to use. Must not be null. If it exists, the current user must be able to access the directory for reading and
         *                      writing. If the directory does not exist then the current user must be able to create it for reading and writing.
         * @return The builder itself.
         */
        @Nonnull
        public Builder setDataDirectory(@Nonnull String dataDirectory) {
<span class="nc" id="L753">            checkNotNull(dataDirectory, &quot;dataDirectory is null&quot;);</span>
<span class="nc" id="L754">            return setDataDirectory(new File(dataDirectory));</span>
        }

        /**
         * Explicitly set the location of the data directory. Default is using a managed directory.
         *
         * @param dataDirectory The directory to use. Must not be null. If it exists, the current user must be able to access the directory for reading and
         *                      writing. If the directory does not exist then the current user must be able to create it for reading and writing.
         * @return The builder itself.
         */
        @Nonnull
        public Builder setDataDirectory(@Nonnull File dataDirectory) {
<span class="fc" id="L766">            this.dataDirectory = checkNotNull(dataDirectory, &quot;dataDirectory is null&quot;);</span>
<span class="fc" id="L767">            return this;</span>
        }

        /**
         * Adds a server configuration parameter. All parameters are passed to the PostgreSQL server a startup using the &lt;code&gt;postgres&lt;/code&gt; command.
         * &lt;p&gt;
         * Values and their function are specific to the PostgreSQL version selected.
         * &lt;p&gt;
         * See &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;the PostgreSQL runtime configuration&lt;/a&gt; for more information.
         *
         * @param key   Configuration parameter name. Must not be null.
         * @param value Configuration parameter value. Must not be null.
         * @return The builder itself.
         */
        @Nonnull
        public Builder addServerConfiguration(@Nonnull String key, @Nonnull String value) {
<span class="nc" id="L783">            checkNotNull(key, &quot;key is null&quot;);</span>
<span class="nc" id="L784">            checkNotNull(value, &quot;value is null&quot;);</span>
<span class="nc" id="L785">            this.serverConfiguration.put(key, value);</span>
<span class="nc" id="L786">            return this;</span>
        }

        /**
         * Adds a configuration parameters for the &lt;code&gt;initdb&lt;/code&gt; command. The &lt;code&gt;initdb&lt;/code&gt; command is used to create the PostgreSQL server.
         * &lt;p&gt;
         * Each value is added as a command line parameter to the command.
         * &lt;p&gt;
         * See the &lt;a href=&quot;https://www.postgresql.org/docs/13/app-initdb.html&quot;&gt;PostgreSQL initdb documentation&lt;/a&gt; for an overview of possible values.
         *
         * @param key   initdb parameter name. Must not be null.
         * @param value initdb parameter value. Must not be null. When the empty string is used as the value, the resulting command line parameter will not have
         *              a equal sign and a value assigned.
         * @return The builder itself.
         * @since 3.0
         */
        @Nonnull
        public Builder addInitDbConfiguration(@Nonnull String key, @Nonnull String value) {
<span class="fc" id="L804">            checkNotNull(key, &quot;key is null&quot;);</span>
<span class="fc" id="L805">            checkNotNull(value, &quot;value is null&quot;);</span>
<span class="fc" id="L806">            this.localeConfiguration.put(key, value);</span>
<span class="fc" id="L807">            return this;</span>
        }

        /**
         * Adds a connection property. These properties are set on every connection handed out by the data source. See
         * &lt;a href=&quot;https://jdbc.postgresql.org/documentation/head/connect.html#connection-parameters&quot;&gt;the
         * PostgreSQL JDBC driver documentation&lt;/a&gt; for possible values.
         *
         * @param key   connection property name. Must not be null.
         * @param value connection property value. Must not be null.
         * @return The builder itself.
         */
        @Nonnull
        public Builder addConnectionProperty(@Nonnull String key, @Nonnull String value) {
<span class="fc" id="L821">            checkNotNull(key, &quot;key is null&quot;);</span>
<span class="fc" id="L822">            checkNotNull(value, &quot;value is null&quot;);</span>
<span class="fc" id="L823">            this.connectionProperties.put(key, value);</span>
<span class="fc" id="L824">            return this;</span>
        }

        /**
         * Sets the directory where the PostgreSQL distribution is unpacked. Setting the installation base directory resets the {@link NativeBinaryManager} used
         * to locate the postgres installation back to the default (which is to download the zonky.io Postgres archive and unpack it in the installation
         * directory. The default is using a managed directory.
         *
         * @param installationBaseDirectory The directory to unpack the postgres distribution. The current user must be able to create and write this directory.
         *                                  Must not be null.
         * @return The builder itself.
         * @since 3.0
         */
        @Nonnull
        public Builder setInstallationBaseDirectory(@Nonnull File installationBaseDirectory) {
<span class="nc" id="L839">            checkNotNull(installationBaseDirectory, &quot;installationBaseDirectory is null&quot;);</span>
<span class="nc" id="L840">            this.installationBaseDirectory = installationBaseDirectory;</span>
<span class="nc" id="L841">            this.nativeBinaryManager = null;</span>
<span class="nc" id="L842">            return this;</span>
        }

        /**
         * Explicitly set the TCP port for the PostgreSQL server. If the port is not available, starting the server will fail. Default is to find and use an
         * available TCP port.
         *
         * @param port The port to use. Must be &amp;gt; 1023 and &amp;lt; 65536.
         * @return The builder itself.
         */
        @Nonnull
        public Builder setPort(int port) {
<span class="nc bnc" id="L854" title="All 4 branches missed.">            checkState(port &gt; 1_023 &amp;&amp; port &lt; 65_535, &quot;Port %s is not within 1024..65535&quot;, port);</span>
<span class="nc" id="L855">            this.port = port;</span>
<span class="nc" id="L856">            return this;</span>
        }

        /**
         * Set the version of the PostgreSQL server. This value is passed to the default binary manager which will try to resolve this version from existing
         * Maven artifacts. The value is ignored if {@link Builder#setNativeBinaryManager(NativeBinaryManager)} is called.
         * &lt;p&gt;
         * Not every PostgreSQL version is supported by pg-embedded. Some older versions lack the necessary options for the command line parameters and will
         * fail at startup. Currently, every version 10 or newer should be working.
         *
         * @param serverVersion A partial or full version. Valid values are e.g. &quot;12&quot; or &quot;11.3&quot;.
         * @return The builder itself.
         * @since 3.0
         */
        @Nonnull
        public Builder setServerVersion(@Nonnull String serverVersion) {
<span class="nc" id="L872">            this.serverVersion = checkNotNull(serverVersion, &quot;serverVersion is null&quot;);</span>

<span class="nc" id="L874">            return this;</span>
        }

        /**
         * Set a {@link ProcessBuilder.Redirect} instance to receive stderr output from the spawned processes.
         *
         * @param errorRedirector a {@link ProcessBuilder.Redirect} instance. Must not be null.
         * @return The builder itself.
         */
        @Nonnull
        public Builder setErrorRedirector(@Nonnull ProcessBuilder.Redirect errorRedirector) {
<span class="nc" id="L885">            this.errorRedirector = checkNotNull(errorRedirector, &quot;errorRedirector is null&quot;);</span>
<span class="nc" id="L886">            return this;</span>
        }

        /**
         * Set a {@link ProcessBuilder.Redirect} instance to receive stdout output from the spawned processes.
         *
         * @param outputRedirector a {@link ProcessBuilder.Redirect} instance. Must not be null.
         * @return The builder itself.
         */
        @Nonnull
        public Builder setOutputRedirector(@Nonnull ProcessBuilder.Redirect outputRedirector) {
<span class="nc" id="L897">            this.outputRedirector = checkNotNull(outputRedirector, &quot;outputRedirector is null&quot;);</span>
<span class="nc" id="L898">            return this;</span>
        }

        /**
         * Sets the {@link NativeBinaryManager} that provides the location of the postgres installation. Explicitly setting a binary manager overrides the
         * installation base directory location set with {@link Builder#setInstallationBaseDirectory(File)} as this is only used by the default binary manager.
         * Calling {@link Builder#setInstallationBaseDirectory(File)} after this method undoes setting the binary manager.
         *
         * @param nativeBinaryManager A {@link NativeBinaryManager} implementation. Must not be null.
         * @return The builder itself.
         * @since 3.0
         */
        @Nonnull
        public Builder setNativeBinaryManager(@Nonnull NativeBinaryManager nativeBinaryManager) {
<span class="fc" id="L912">            this.nativeBinaryManager = checkNotNull(nativeBinaryManager, &quot;nativeBinaryManager is null&quot;);</span>
<span class="fc" id="L913">            return this;</span>
        }

        /**
         * Use a locally installed PostgreSQL server for tests. The tests will still spin up a new instance and locate the data in the data directory but it
         * will use the locally installed binaries for starting and stopping. Calling this method sets a binary manager, so it overrides
         * {@link Builder#setNativeBinaryManager(NativeBinaryManager)}. Calling this method makes the builder ignore the
         * {@link Builder#setInstallationBaseDirectory(File)} setting.
         *
         * @param directory A local directory that contains a standard PostgreSQL installation. The directory must exist and read and executable.
         * @return The builder itself.
         * @since 3.0
         */
        @Nonnull
        public Builder useLocalPostgresInstallation(@Nonnull File directory) {
<span class="nc" id="L928">            checkNotNull(directory, &quot;directory is null&quot;);</span>
<span class="nc bnc" id="L929" title="All 4 branches missed.">            checkState(directory.exists() &amp;&amp; directory.isDirectory(), &quot;'%s' either does not exist or is not a directory!&quot;, directory);</span>
<span class="nc" id="L930">            return setNativeBinaryManager(() -&gt; directory);</span>
        }

        /**
         * Creates and boots a new {@link EmbeddedPostgres} instance.
         *
         * @return A {@link EmbeddedPostgres} instance representing a started PostgreSQL server.
         * @throws IOException If the server could not be installed or started.
         */
        @Nonnull
        public EmbeddedPostgres build() throws IOException {
            // Builder Id
<span class="fc" id="L942">            final String instanceId = EmbeddedUtil.randomAlphaNumeric(16);</span>

<span class="pc bpc" id="L944" title="1 of 2 branches missed.">            int port = this.port != 0 ? this.port : EmbeddedUtil.allocatePort();</span>

            // installation root if nothing has been set by the user.
<span class="fc" id="L947">            final File parentDirectory = EmbeddedUtil.getWorkingDirectory();</span>

<span class="fc" id="L949">            NativeBinaryManager nativeBinaryManager = this.nativeBinaryManager;</span>
<span class="fc bfc" id="L950" title="All 2 branches covered.">            if (nativeBinaryManager == null) {</span>
<span class="fc" id="L951">                final String serverVersion = System.getProperty(&quot;pg-embedded.postgres-version&quot;, this.serverVersion);</span>
<span class="fc" id="L952">                nativeBinaryManager = new TarXzCompressedBinaryManager(new ZonkyIOPostgresLocator(serverVersion));</span>
            }

            // Use the parent directory if no installation directory set.
<span class="fc" id="L956">            File installationBaseDirectory = Objects.requireNonNullElse(this.installationBaseDirectory, parentDirectory);</span>
<span class="fc" id="L957">            nativeBinaryManager.setInstallationBaseDirectory(installationBaseDirectory);</span>

            // this is where the binary manager actually places the unpackaged postgres installation.
<span class="fc" id="L960">            final File postgresInstallDirectory = nativeBinaryManager.getLocation();</span>

<span class="fc" id="L962">            File dataDirectory = this.dataDirectory;</span>
<span class="fc bfc" id="L963" title="All 2 branches covered.">            if (dataDirectory == null) {</span>
<span class="fc" id="L964">                dataDirectory = new File(parentDirectory, DATA_DIRECTORY_PREFIX + instanceId);</span>
            }

<span class="fc" id="L967">            EmbeddedPostgres embeddedPostgres = new EmbeddedPostgres(instanceId, postgresInstallDirectory, dataDirectory,</span>
                    removeDataOnShutdown, serverConfiguration, localeConfiguration, connectionProperties,
                    port, errorRedirector, outputRedirector,
                    serverStartupWait);

<span class="fc" id="L972">            embeddedPostgres.cleanOldDataDirectories(parentDirectory);</span>

            // for version checking (calling getPostgresVersion(), the instance does not need to run
            // this is a special case to make the version check run faster for unit test selection.
<span class="fc bfc" id="L976" title="All 2 branches covered.">            if (bootInstance) {</span>
<span class="fc" id="L977">                embeddedPostgres.boot();</span>
            }

<span class="fc" id="L980">            return embeddedPostgres;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>